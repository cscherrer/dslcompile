; Test program to debug dependency analysis interaction

; Define datatypes correctly like our real system
(datatype Math
  (Num f64)
  (UserVar i64)
  (BoundVar i64)
  (Add Math Math)
  (Mul Math Math)
  (Sub Math Math)
  (Div Math Math)
  (Pow Math Math)
  (Let i64 Math Math)
)

; Separate collection datatype
(datatype Collection
  (Empty)
  (Singleton Math)
  (Range Math Math)
  (DataArray i64)
)

; Lambda datatype
(datatype Lambda
  (LambdaFunc i64 Math)
  (Identity)
  (ConstantFunc Math)
)

; Sum constructor takes Collection, returns Math
(constructor Sum (Collection) Math)
(constructor Map (Lambda Collection) Collection)

; Minimal dependency analysis
(datatype VarSet
  (EmptySet)
  (SingleVar i64)
  (UnionSet VarSet VarSet))

(function free-vars (Math) VarSet :merge (UnionSet old new))

; Base cases only
(rule ((Num ?c))
      ((set (free-vars (Num ?c)) (EmptySet))))

(rule ((UserVar ?v))
      ((set (free-vars (UserVar ?v)) (SingleVar ?v))))

; Now add composite rules and see what happens
(rule ((= add_expr (Add ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars add_expr) (UnionSet dep_a dep_b))))

(rule ((= mul_expr (Mul ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars mul_expr) (UnionSet dep_a dep_b))))

; Sum dependency analysis - this is where complexity explodes
(rule ((= sum_expr (Sum ?collection)))
      ((set (free-vars sum_expr) (EmptySet)))) ; Simplified for now

; Add math rules from staged_core_math.egg one by one
(rewrite (Add (Num ?a) (Num ?b)) (Num (+ ?a ?b)))
(rewrite (Add (Num 0.0) ?x) ?x)
(rewrite (Add ?x (Num 0.0)) ?x)
(rewrite (Mul (Num ?a) (Num ?b)) (Num (* ?a ?b)))
(rewrite (Mul (Num 1.0) ?x) ?x)
(rewrite (Mul ?x (Num 1.0)) ?x)

; Let binding evaluation - this might interact with dependency analysis
(rewrite (Let ?id ?expr (BoundVar ?id)) ?expr)

; Empty sum rules - these might cause problems with dependency tracking
(rewrite (Sum (Empty)) (Num 0.0))
(rewrite (Sum (Singleton ?expr)) ?expr)

; Create a more complex test expression with Sum
(let x (UserVar 1))
(let y (UserVar 2))
(let z (Num 3.0))
(let expr1 (Add x y))
(let expr2 (Mul expr1 z))
(let expr3 (Add expr2 x))

; Test Sum expression
(let simple_collection (Singleton x))
(let sum_expr (Sum simple_collection))

; Run with more iterations like our real system
(run 100)

; Check the dependencies
(query-extract (free-vars expr3))
(query-extract (free-vars sum_expr))