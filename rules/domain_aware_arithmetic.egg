; Domain-Aware Arithmetic Rules for MathCompile
; Safe mathematical transformations with domain preconditions

; ========================================
; IEEE 754 COMPLIANT RULES
; ========================================

; NOTE: IEEE 754 standard rules are defined in basic_arithmetic.egg
; This section is reserved for domain-specific IEEE 754 optimizations

; ========================================
; SAFE POWER RULES
; ========================================

; NOTE: Basic power rules are defined in basic_arithmetic.egg
; This section is reserved for domain-specific power optimizations

; x^0 = 1 for x ≠ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≠ 0
; In practice, this would be handled by the domain-aware rule generator

; ========================================
; SAFE DIVISION RULES
; ========================================

; x/1 = x (always safe)
(rewrite (Div ?x (Num 1.0)) ?x)

; x/x = 1 for x ≠ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≠ 0
; In practice, this would be handled by the domain-aware rule generator

; ========================================
; SAFE SQUARE ROOT RULES
; ========================================

; NOTE: Basic square root rules are defined in transcendental.egg
; This section is reserved for domain-specific square root optimizations

; √(x²) = |x| (mathematically correct)
; For x ≥ 0: √(x²) = x (requires domain analysis)
; For x < 0: √(x²) = -x (requires domain analysis)
; The general case requires absolute value, which we don't have in our AST yet

; (√x)² = x for x ≥ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≥ 0

; ========================================
; SAFE LOGARITHM RULES
; ========================================

; NOTE: Basic logarithm rules are defined in transcendental.egg
; This section is reserved for domain-specific logarithm optimizations

; ========================================
; SAFE EXPONENTIAL RULES
; ========================================

; NOTE: Basic exponential rules are defined in transcendental.egg
; This section is reserved for domain-specific exponential optimizations

; ========================================
; CONSERVATIVE FALLBACKS
; ========================================

; When domain information is unavailable, we use conservative rules
; that are always mathematically sound, even if less optimal

; For expressions where we cannot guarantee safety, we avoid transformation
; This prevents incorrect optimizations that could lead to NaN or undefined behavior

; ========================================
; DOMAIN-SPECIFIC OPTIMIZATIONS
; ========================================

; These rules would be generated dynamically based on domain analysis:
;
; If x ∈ (0, +∞):
;   (rewrite (Pow ?x (Num 0.0)) (Num 1.0))
;   (rewrite (Div ?x ?x) (Num 1.0))
;   (rewrite (Exp (Ln ?x)) ?x)
;
; If x ∈ [0, +∞):
;   (rewrite (Sqrt (Mul ?x ?x)) ?x)
;   (rewrite (Pow (Sqrt ?x) (Num 2.0)) ?x)
;
; If x ∈ (-∞, 0):
;   (rewrite (Sqrt (Mul ?x ?x)) (Neg ?x))
;
; These would be generated by the RuleLoader based on IntervalDomain analysis 