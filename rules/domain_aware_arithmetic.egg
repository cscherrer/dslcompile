; Domain-Aware Arithmetic Rules for MathCompile
; Safe mathematical transformations with domain preconditions

; ========================================
; IEEE 754 COMPLIANT RULES
; ========================================

; IEEE 754 standard defines these computational results
; Note: These are computational conventions, not mathematical truths

; 0^0 = 1 (IEEE 754 convention)
(rewrite (Pow (Num 0.0) (Num 0.0)) (Num 1.0))

; ========================================
; SAFE POWER RULES
; ========================================

; x^1 = x (always safe)
(rewrite (Pow ?x (Num 1.0)) ?x)

; 1^x = 1 (always safe)
(rewrite (Pow (Num 1.0) ?x) (Num 1.0))

; x^0 = 1 for x ≠ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≠ 0
; In practice, this would be handled by the domain-aware rule generator

; ========================================
; SAFE DIVISION RULES
; ========================================

; x/1 = x (always safe)
(rewrite (Div ?x (Num 1.0)) ?x)

; x/x = 1 for x ≠ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≠ 0
; In practice, this would be handled by the domain-aware rule generator

; ========================================
; SAFE SQUARE ROOT RULES
; ========================================

; √1 = 1 (always safe)
(rewrite (Sqrt (Num 1.0)) (Num 1.0))

; √0 = 0 (always safe)
(rewrite (Sqrt (Num 0.0)) (Num 0.0))

; √(x²) = |x| (mathematically correct)
; For x ≥ 0: √(x²) = x (requires domain analysis)
; For x < 0: √(x²) = -x (requires domain analysis)
; The general case requires absolute value, which we don't have in our AST yet

; (√x)² = x for x ≥ 0 (requires domain analysis for safety)
; This rule should only be applied when we know x ≥ 0

; ========================================
; SAFE LOGARITHM RULES
; ========================================

; ln(1) = 0 (always safe)
(rewrite (Ln (Num 1.0)) (Num 0.0))

; ln(e^x) = x (always safe)
(rewrite (Ln (Exp ?x)) ?x)

; e^(ln(x)) = x for x > 0 (requires domain analysis for safety)
; This rule should only be applied when we know x > 0

; ========================================
; SAFE EXPONENTIAL RULES
; ========================================

; e^0 = 1 (always safe)
(rewrite (Exp (Num 0.0)) (Num 1.0))

; e^(ln(x)) = x for x > 0 (requires domain analysis)
; This is handled in the transcendental rules with appropriate domain checks

; ========================================
; CONSERVATIVE FALLBACKS
; ========================================

; When domain information is unavailable, we use conservative rules
; that are always mathematically sound, even if less optimal

; For expressions where we cannot guarantee safety, we avoid transformation
; This prevents incorrect optimizations that could lead to NaN or undefined behavior

; ========================================
; DOMAIN-SPECIFIC OPTIMIZATIONS
; ========================================

; These rules would be generated dynamically based on domain analysis:
;
; If x ∈ (0, +∞):
;   (rewrite (Pow ?x (Num 0.0)) (Num 1.0))
;   (rewrite (Div ?x ?x) (Num 1.0))
;   (rewrite (Exp (Ln ?x)) ?x)
;
; If x ∈ [0, +∞):
;   (rewrite (Sqrt (Mul ?x ?x)) ?x)
;   (rewrite (Pow (Sqrt ?x) (Num 2.0)) ?x)
;
; If x ∈ (-∞, 0):
;   (rewrite (Sqrt (Mul ?x ?x)) (Neg ?x))
;
; These would be generated by the RuleLoader based on IntervalDomain analysis 