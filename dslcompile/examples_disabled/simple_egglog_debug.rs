//! Simple Egglog Debug Test\n//!\n//! Minimal test to debug why sum splitting isn't working\n\nuse dslcompile::prelude::*;\n\nfn main() -> Result<()> {\n    println!(\"üîç Simple Egglog Debug Test\");\n    \n    let mut ctx = DynamicContext::new();\n    let a = ctx.var::<f64>();\n    let b = ctx.var::<f64>();\n    let test_data = vec![1.0, 2.0, 3.0];\n    \n    // Create: Œ£(a * x_i + b * x_i)\n    let sum_expr = ctx.sum(&test_data, |x_i| &a * &x_i + &b * &x_i);\n    let original_ast = ctx.to_ast(&sum_expr);\n    \n    println!(\"\\nüìù Original AST:\");\n    println!(\"{:#?}\", original_ast);\n    \n    #[cfg(feature = \"optimization\")]\n    {\n        use dslcompile::symbolic::native_egglog::NativeEgglogOptimizer;\n        \n        println!(\"\\nüîß Converting to Egglog...\");\n        let optimizer = NativeEgglogOptimizer::new()?;\n        let egglog_string = optimizer.ast_to_egglog(&original_ast)?;\n        \n        println!(\"Egglog representation: {}\", egglog_string);\n        \n        println!(\"\\nüéØ Pattern Analysis:\");\n        println!(\"Expected rule pattern: (Sum (Map (LambdaFunc ?var (Add ?f ?g)) ?collection))\");\n        println!(\"Our actual structure: {}\", egglog_string);\n        \n        // Check if they match structurally\n        if egglog_string.contains(\"Sum\") && egglog_string.contains(\"Map\") && egglog_string.contains(\"LambdaFunc\") && egglog_string.contains(\"Add\") {\n            println!(\"‚úÖ Structure looks correct for sum splitting rule\");\n        } else {\n            println!(\"‚ùå Structure doesn't match expected pattern\");\n            if !egglog_string.contains(\"Sum\") { println!(\"   Missing: Sum\"); }\n            if !egglog_string.contains(\"Map\") { println!(\"   Missing: Map\"); }\n            if !egglog_string.contains(\"LambdaFunc\") { println!(\"   Missing: LambdaFunc\"); }\n            if !egglog_string.contains(\"Add\") { println!(\"   Missing: Add\"); }\n        }\n        \n        println!(\"\\nüß™ Testing optimization...\");\n        match optimizer.optimize(&original_ast) {\n            Ok(optimized) => {\n                let optimized_egglog = optimizer.ast_to_egglog(&optimized)?;\n                println!(\"Optimized: {}\", optimized_egglog);\n                \n                if egglog_string != optimized_egglog {\n                    println!(\"‚úÖ Expression was transformed!\");\n                } else {\n                    println!(\"‚ùå No transformation occurred\");\n                }\n            }\n            Err(e) => {\n                println!(\"‚ùå Optimization failed: {}\", e);\n            }\n        }\n    }\n    \n    #[cfg(not(feature = \"optimization\"))]\n    {\n        println!(\"‚ö†Ô∏è  Run with --features optimization\");\n    }\n    \n    Ok(())\n} 