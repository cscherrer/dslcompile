; Basic Arithmetic Rules for DSLCompile
; Identity, commutativity, and associativity rules for fundamental operations
; Static with canonical forms and comprehensive algebraic simplifications
; NOTE: These are conservative rules that are always mathematically sound

; ========================================
; CANONICAL FORM RULES
; ========================================
; Standardize expressions to preferred representations

; Convert subtraction to addition with negation (canonical form)
(rewrite (Sub ?x ?y) (Add ?x (Neg ?y)))

; Convert division to multiplication with reciprocal (when beneficial)
; NOTE: Only when the denominator is a literal to avoid introducing more complexity
(rewrite (Div ?x (Num ?n)) (Mul ?x (Num (/ 1.0 ?n))) :when (> ?n 0.0001))

; Normalize negation placement
(rewrite (Neg (Neg ?x)) ?x)                    ; Double negation elimination
(rewrite (Add (Neg ?x) ?y) (Sub ?y ?x))        ; -x + y = y - x (sometimes cleaner)
(rewrite (Mul (Neg ?x) ?y) (Neg (Mul ?x ?y)))  ; (-x) * y = -(x * y)
(rewrite (Mul ?x (Neg ?y)) (Neg (Mul ?x ?y)))  ; x * (-y) = -(x * y)

; ========================================
; COMMUTATIVITY RULES
; ========================================

; Addition and multiplication are commutative
(rewrite (Add ?x ?y) (Add ?y ?x))
(rewrite (Mul ?x ?y) (Mul ?y ?x))

; Min/Max are commutative
(rewrite (Min ?x ?y) (Min ?y ?x))
(rewrite (Max ?x ?y) (Max ?y ?x))

; ========================================
; IDENTITY RULES
; ========================================

; Addition identity: x + 0 = x
(rewrite (Add ?x (Num 0.0)) ?x)
(rewrite (Add (Num 0.0) ?x) ?x)

; Multiplication identity: x * 1 = x
(rewrite (Mul ?x (Num 1.0)) ?x)
(rewrite (Mul (Num 1.0) ?x) ?x)

; Multiplication by zero: x * 0 = 0
(rewrite (Mul ?x (Num 0.0)) (Num 0.0))
(rewrite (Mul (Num 0.0) ?x) (Num 0.0))

; Division identity: x / 1 = x
(rewrite (Div ?x (Num 1.0)) ?x)

; NOTE: x / x = 1 is NOT included here as it's unsafe when x = 0
; This rule is handled in domain_aware_arithmetic.egg with proper preconditions

; Negation identity: -0 = 0
(rewrite (Neg (Num 0.0)) (Num 0.0))

; Absolute value identities
(rewrite (Abs (Num ?n)) (Num (abs ?n)))        ; |constant| = constant
(rewrite (Abs (Abs ?x)) (Abs ?x))              ; ||x|| = |x|
(rewrite (Abs (Neg ?x)) (Abs ?x))              ; |-x| = |x|

; ========================================
; SAFE POWER RULES
; ========================================

; Power identity rules (always safe)
(rewrite (Pow ?x (Num 1.0)) ?x)         ; x^1 = x
(rewrite (Pow (Num 1.0) ?x) (Num 1.0))  ; 1^x = 1
(rewrite (Pow ?x (Num 0.0)) (Num 1.0))  ; x^0 = 1 (IEEE 754 convention, includes 0^0 = 1)

; Special power cases
; DISABLED: This rule is causing mathematical incorrectness for 0^(negative)
(rewrite (Pow (Num 0.0) ?x) (Num 0.0) :when (> ?x 0.0))  ; 0^x = 0 for x > 0
; DISABLED: This canonicalization prevents perfect square expansion from working
; (rewrite (Pow ?x (Num 2.0)) (Mul ?x ?x))                 ; x^2 = x*x
(rewrite (Pow ?x (Num 0.5)) (Sqrt ?x))                   ; x^0.5 = sqrt(x)
(rewrite (Pow ?x (Num -1.0)) (Div (Num 1.0) ?x))         ; x^(-1) = 1/x

; Square root optimizations
(rewrite (Sqrt (Mul ?x ?x)) (Abs ?x))                     ; sqrt(x^2) = |x|
(rewrite (Sqrt (Pow ?x (Num 2.0))) (Abs ?x))             ; sqrt(x^2) = |x|
(rewrite (Mul (Sqrt ?x) (Sqrt ?x)) ?x)                    ; sqrt(x) * sqrt(x) = x (for x >= 0)

; ========================================
; ALGEBRAIC SIMPLIFICATIONS
; ========================================

; Addition of same terms: x + x = 2x
(rewrite (Add ?x ?x) (Mul (Num 2.0) ?x))

; Subtraction of same terms: x - x = 0
(rewrite (Sub ?x ?x) (Num 0.0))

; Factoring: x*y + x*z = x*(y + z)
(rewrite (Add (Mul ?x ?y) (Mul ?x ?z)) (Mul ?x (Add ?y ?z)))
(rewrite (Add (Mul ?y ?x) (Mul ?z ?x)) (Mul (Add ?y ?z) ?x))

; Difference of squares: x^2 - y^2 = (x+y)*(x-y)
(rewrite (Sub (Mul ?x ?x) (Mul ?y ?y)) (Mul (Add ?x ?y) (Sub ?x ?y)))
(rewrite (Sub (Pow ?x (Num 2.0)) (Pow ?y (Num 2.0))) (Mul (Add ?x ?y) (Sub ?x ?y)))

; Perfect square: (x+y)^2 = x^2 + 2xy + y^2
(rewrite (Pow (Add ?x ?y) (Num 2.0)) 
         (Add (Add (Mul ?x ?x) (Mul (Num 2.0) (Mul ?x ?y))) (Mul ?y ?y)))

; Perfect square via multiplication: (x+y)*(x+y) = x^2 + 2xy + y^2
; This catches the case where canonicalization converted (x+y)^2 to (x+y)*(x+y) first
(rewrite (Mul (Add ?x ?y) (Add ?x ?y))
         (Add (Add (Mul ?x ?x) (Mul (Num 2.0) (Mul ?x ?y))) (Mul ?y ?y)))

; ========================================
; DISTRIBUTIVE PROPERTIES
; ========================================

; Left distributivity: x * (y + z) = x*y + x*z
(rewrite (Mul ?x (Add ?y ?z)) (Add (Mul ?x ?y) (Mul ?x ?z)))

; Right distributivity: (y + z) * x = y*x + z*x
(rewrite (Mul (Add ?y ?z) ?x) (Add (Mul ?y ?x) (Mul ?z ?x)))

; Distributivity over subtraction
(rewrite (Mul ?x (Sub ?y ?z)) (Sub (Mul ?x ?y) (Mul ?x ?z)))
(rewrite (Mul (Sub ?y ?z) ?x) (Sub (Mul ?y ?x) (Mul ?z ?x)))

; ========================================
; CONSTANT FOLDING RULES
; ========================================

; Fold arithmetic operations on constants
(rewrite (Add (Num ?x) (Num ?y)) (Num (+ ?x ?y)))
(rewrite (Sub (Num ?x) (Num ?y)) (Num (- ?x ?y)))
(rewrite (Mul (Num ?x) (Num ?y)) (Num (* ?x ?y)))
(rewrite (Div (Num ?x) (Num ?y)) (Num (/ ?x ?y)) :when (!= ?y 0.0))
; DISABLED: Power constant folding - egglog's pow function is mathematically incorrect for edge cases
; (rewrite (Pow (Num ?x) (Num ?y)) (Num (pow ?x ?y)) 
;   :when (or (!= ?x 0.0) (>= ?y 0.0)))

; Fold comparison operations on constants
(rewrite (Min (Num ?x) (Num ?y)) (Num (min ?x ?y)))
(rewrite (Max (Num ?x) (Num ?y)) (Num (max ?x ?y)))

; ========================================
; SIMPLIFICATION PREFERENCES
; ========================================

; Prefer fewer operations when equivalent
(rewrite (Add ?x (Neg ?x)) (Num 0.0))              ; x + (-x) = 0
(rewrite (Add (Neg ?x) ?x) (Num 0.0))              ; (-x) + x = 0
(rewrite (Mul ?x (Div (Num 1.0) ?x)) (Num 1.0))    ; x * (1/x) = 1 (for x != 0)

; Collect like terms
(rewrite (Add (Mul (Num ?a) ?x) (Mul (Num ?b) ?x)) (Mul (Num (+ ?a ?b)) ?x))
(rewrite (Sub (Mul (Num ?a) ?x) (Mul (Num ?b) ?x)) (Mul (Num (- ?a ?b)) ?x))

; ========================================
; POWER CANONICALIZATION RULES  
; ========================================
; Convert repeated multiplication to power form for better pattern recognition

; Convert x*x to x^2 (canonical power form)
; DISABLED: This conflicts with perfect square expansion (a+b)^2 → a^2 + 2ab + b^2
; (rewrite (Mul ?x ?x) (Pow ?x (Num 2.0)))

; Convert x*x*x to x^3 (requires associativity first)
; Note: This will be handled by repeated application of the above rule
; due to associativity: (x*x)*x → x^2*x, then we need additional rules 