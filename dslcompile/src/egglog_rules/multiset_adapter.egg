; Multiset Adapter for Binary AST
; This provides multiset-based optimization while keeping binary AST structure
;
; Strategy: 
; 1. Keep Add(Math, Math) and Mul(Math, Math) as they are in the AST
; 2. Create MultiAdd(MathSet) and MultiMul(MathSet) for optimization
; 3. Convert between them with controlled rules

; ========================================
; MULTISET OPERATIONS (PARALLEL TO BINARY)
; ========================================

; Define multiset sort
(sort MathSet (MultiSet Math))

; Define multiset operations that parallel binary ones
(function MultiAdd (MathSet) Math)
(function MultiMul (MathSet) Math)

; ========================================
; CONTROLLED CONVERSION TO MULTISETS
; ========================================

; Convert binary to multiset form - but only at the top level to avoid explosion
(rewrite (Add a b) (MultiAdd (multiset-of a b)) :subsume)
(rewrite (Mul a b) (MultiMul (multiset-of a b)) :subsume)

; ========================================
; FLATTEN INTO MULTISETS
; ========================================

; When building multisets, flatten any nested multiset operations
(rewrite (MultiAdd (multiset-of a (MultiAdd ms)))
         (MultiAdd (multiset-insert ms a))
         :subsume)

(rewrite (MultiAdd (multiset-of (MultiAdd ms) b))
         (MultiAdd (multiset-insert ms b))
         :subsume)

(rewrite (MultiMul (multiset-of a (MultiMul ms)))
         (MultiMul (multiset-insert ms a))
         :subsume)

(rewrite (MultiMul (multiset-of (MultiMul ms) b))
         (MultiMul (multiset-insert ms b))
         :subsume)

; ========================================
; SIMPLIFICATION IN MULTISET FORM
; ========================================

; Empty/single element simplification
(rewrite (MultiAdd ms)
         (Num 0.0)
         :when ((= 0 (multiset-length ms))))

(rewrite (MultiAdd ms)
         (multiset-pick ms)
         :when ((= 1 (multiset-length ms))))

(rewrite (MultiMul ms)
         (Num 1.0)
         :when ((= 0 (multiset-length ms))))

(rewrite (MultiMul ms)
         (multiset-pick ms)
         :when ((= 1 (multiset-length ms))))

; ========================================
; CONSTANT FOLDING IN MULTISETS
; ========================================

; Fold constants in additions
(rule
  ((= sum (MultiAdd ms))
   (= num-a (Num a))
   (multiset-contains ms num-a)
   (= ms-without-a (multiset-remove ms num-a))
   (= num-b (Num b))
   (multiset-contains ms-without-a num-b))
  ((set (MultiAdd ms)
        (MultiAdd (multiset-insert 
                   (multiset-remove ms-without-a num-b) 
                   (Num (+ a b)))))))

; Fold constants in multiplications
(rule
  ((= prod (MultiMul ms))
   (= num-a (Num a))
   (multiset-contains ms num-a)
   (= ms-without-a (multiset-remove ms num-a))
   (= num-b (Num b))
   (multiset-contains ms-without-a num-b))
  ((set (MultiMul ms)
        (MultiMul (multiset-insert 
                   (multiset-remove ms-without-a num-b) 
                   (Num (* a b)))))))

; ========================================
; IDENTITY ELIMINATION
; ========================================

; Remove zeros from additions
(rule
  ((= sum (MultiAdd ms))
   (multiset-contains ms (Num 0.0)))
  ((set (MultiAdd ms)
        (MultiAdd (multiset-remove ms (Num 0.0))))))

; Remove ones from multiplications
(rule
  ((= prod (MultiMul ms))
   (multiset-contains ms (Num 1.0)))
  ((set (MultiMul ms)
        (MultiMul (multiset-remove ms (Num 1.0))))))

; Zero in multiplication
(rewrite (MultiMul ms)
         (Num 0.0)
         :when ((multiset-contains ms (Num 0.0))))

; ========================================
; COST MODEL
; ========================================

; Make multiset operations cheaper than binary trees
(cost (MultiAdd ms) (multiset-length ms))
(cost (MultiMul ms) (* 2 (multiset-length ms)))

; Binary operations have higher cost to prefer multiset form
(cost (Add a b) 10)
(cost (Mul a b) 20)