; Collection-Based Summation Rules for DSLCompile
; Implements Map-based summation with bidirectional mathematical identities
; This replaces range-based summation with more expressive collection operations

; ========================================
; UNIFIED EXPRESSION DATATYPE (No Circular Dependencies)
; ========================================

; Single unified datatype that includes all math, collection, and lambda operations
(datatype Expr
  ; Basic math operations
  (Num f64)
  (Var String)
  (Add Expr Expr)
  (Sub Expr Expr)
  (Mul Expr Expr)
  (Div Expr Expr)
  (Pow Expr Expr)
  (Neg Expr)
  (Abs Expr)
  (Ln Expr)
  (Exp Expr)
  (Sin Expr)
  (Cos Expr)
  (Sqrt Expr)
  
  ; Collection constructors
  (Empty)                           ; Empty collection
  (Singleton Expr)                  ; Single element collection
  (Range Expr Expr)                 ; Mathematical range [start, end]
  (Union Expr Expr)                 ; Set union
  (Intersection Expr Expr)          ; Set intersection
  (DataArray String)                ; Named data array for runtime binding
  (Filter Expr Expr)                ; Filtered collection with predicate
  
  ; Lambda constructors
  (Lambda String Expr)              ; lambda x -> expr
  (Identity)                        ; lambda x -> x
  (Constant Expr)                   ; lambda x -> c
  (Compose Expr Expr)               ; Function composition
  
  ; Collection-based operations
  (Sum Expr Expr)                   ; Sum over collection with mapping function
  (Map Expr Expr)                   ; Apply function to each element
  (Size Expr)                       ; Collection size
  (App Expr Expr)                   ; Function application
)

; ========================================
; COST MODEL
; ========================================

(function cost (Expr) i64)

; Basic math costs
(set (cost (Num ?n)) 1)
(set (cost (Var ?x)) 1)
(set (cost (Add ?x ?y)) (+ 1 (cost ?x) (cost ?y)))
(set (cost (Sub ?x ?y)) (+ 1 (cost ?x) (cost ?y)))
(set (cost (Mul ?x ?y)) (+ 2 (cost ?x) (cost ?y)))
(set (cost (Div ?x ?y)) (+ 3 (cost ?x) (cost ?y)))
(set (cost (Pow ?x ?y)) (+ 5 (cost ?x) (cost ?y)))
(set (cost (Neg ?x)) (+ 1 (cost ?x)))
(set (cost (Abs ?x)) (+ 1 (cost ?x)))
(set (cost (Ln ?x)) (+ 3 (cost ?x)))
(set (cost (Exp ?x)) (+ 3 (cost ?x)))
(set (cost (Sin ?x)) (+ 3 (cost ?x)))
(set (cost (Cos ?x)) (+ 3 (cost ?x)))
(set (cost (Sqrt ?x)) (+ 2 (cost ?x)))

; Collection costs
(set (cost (Empty)) 0)
(set (cost (Singleton ?x)) (+ 1 (cost ?x)))
(set (cost (Range ?start ?end)) (+ 2 (cost ?start) (cost ?end)))
(set (cost (Union ?x ?y)) (+ 5 (cost ?x) (cost ?y)))
(set (cost (Intersection ?x ?y)) (+ 8 (cost ?x) (cost ?y)))
(set (cost (DataArray ?name)) 1)
(set (cost (Filter ?coll ?pred)) (+ 10 (cost ?coll) (cost ?pred)))

; Lambda costs
(set (cost (Lambda ?var ?expr)) (+ 2 (cost ?expr)))
(set (cost (Identity)) 0)
(set (cost (Constant ?c)) (cost ?c))
(set (cost (Compose ?f ?g)) (+ 3 (cost ?f) (cost ?g)))

; Operation costs
(set (cost (Map ?f ?coll)) (+ 5 (cost ?f) (cost ?coll)))
(set (cost (Sum ?coll ?f)) (+ 10 (cost ?coll) (cost ?f)))
(set (cost (Size ?coll)) (+ 1 (cost ?coll)))
(set (cost (App ?f ?x)) (+ 1 (cost ?f) (cost ?x)))

; ========================================
; BIDIRECTIONAL MATHEMATICAL IDENTITIES
; ========================================

; Linearity - always valid in both directions
(rewrite (Sum ?X (Lambda ?x (Add (App ?f (Var ?x)) (App ?g (Var ?x)))))
         (Add (Sum ?X (Lambda ?x (App ?f (Var ?x))))
              (Sum ?X (Lambda ?x (App ?g (Var ?x))))))

; Identity map
(rewrite (Sum ?X (Lambda ?x (Var ?x)))
         (Sum ?X (Identity)))

; Map composition
(rewrite (Sum (Map ?g ?X) ?f)
         (Sum ?X (Compose ?f ?g)))

; Inclusion-exclusion principle (DEFERRED - Union/Intersection not in core focus)
; (rewrite (Sum (Union ?X ?Y) ?f)
;          (Sub (Add (Sum ?X ?f) (Sum ?Y ?f)) 
;               (Sum (Intersection ?X ?Y) ?f)))

; Associativity of addition in maps
(rewrite (Sum ?X (Lambda ?x (Add (Add (App ?f (Var ?x)) (App ?g (Var ?x))) (App ?h (Var ?x)))))
         (Sum ?X (Lambda ?x (Add (App ?f (Var ?x)) (Add (App ?g (Var ?x)) (App ?h (Var ?x)))))))

; ========================================
; CONDITIONAL/DIRECTIONAL RULES
; ========================================

; Constant extraction - requires constancy analysis
(rule ((constant-wrt ?k ?x))
      ((= ?expr1 (Sum ?X (Lambda ?x (Mul ?k (App ?f (Var ?x))))))
       (= ?expr2 (Mul ?k (Sum ?X (Lambda ?x (App ?f (Var ?x))))))
       (union ?expr1 ?expr2)))

; Disjoint union - only when sets don't overlap (DEFERRED - Union not in core focus)
; (rule ((disjoint ?X ?Y))
;       ((= ?expr1 (Sum (Union ?X ?Y) ?f))
;        (= ?expr2 (Add (Sum ?X ?f) (Sum ?Y ?f)))
;        (union ?expr1 ?expr2)))

; Optimization rules - directional to avoid infinite expansion
(rewrite (Sum ?X (Lambda ?x (Num 0.0)))
         (Num 0.0))

(rewrite (Sum (Empty) ?f)
         (Num 0.0))

(rewrite (Sum (Singleton ?x) ?f)
         (App ?f ?x))

; Constant map over finite collection
(rule ((has-finite-size ?X) (constant-wrt ?k ?x))
      ((= ?expr1 (Sum ?X (Lambda ?x ?k)))
       (= ?expr2 (Mul ?k (Size ?X)))
       (union ?expr1 ?expr2)))

; Scaling sum - directional for performance
(rewrite (Mul ?k (Sum ?X ?f))
         (Sum ?X (Lambda ?x (Mul ?k (App ?f (Var ?x))))))

; Subtraction linearity
(rule ((constant-wrt ?k ?x))
      ((= ?expr1 (Sum ?X (Lambda ?x (Sub (App ?f (Var ?x)) ?k))))
       (= ?expr2 (Sub (Sum ?X (Lambda ?x (App ?f (Var ?x)))) 
                      (Mul ?k (Size ?X))))
       (union ?expr1 ?expr2)))

; ========================================
; SUPPORTING PREDICATES AND FACTS
; ========================================

; Constancy analysis
(rule ((not (free-var ?x ?expr)))
      ((constant-wrt ?expr ?x)))

; Built-in constants
(constant-wrt (Num ?n) ?x)

; Size properties
(has-finite-size (Empty))
(has-finite-size (Singleton ?x))
(has-finite-size (Range ?start ?end))

; (rule ((has-finite-size ?X) (has-finite-size ?Y))
;       ((has-finite-size (Union ?X ?Y))))

; Disjointness properties (DEFERRED - mainly for Union/Intersection)
; (disjoint (Empty) ?X)
; (disjoint ?X (Empty))

; (rule ((disjoint ?X ?Y))
;       ((disjoint ?Y ?X)))

; Non-overlapping ranges (DEFERRED - mainly for Union/Intersection)
; (rule ((< ?end1 ?start2))
;       ((disjoint (Range ?start1 ?end1) (Range ?start2 ?end2))))

; Size calculations
(rewrite (Size (Empty)) (Num 0.0))
(rewrite (Size (Singleton ?x)) (Num 1.0))
(rule ((>= ?end ?start))
      ((= ?expr1 (Size (Range ?start ?end)))
       (= ?expr2 (Add (Sub ?end ?start) (Num 1.0)))
       (union ?expr1 ?expr2)))

; ========================================
; COLLECTION OPERATIONS
; ========================================

; Empty intersection with disjoint sets (DEFERRED - Intersection not in core focus)
; (rule ((disjoint ?X ?Y))
;       ((= ?expr1 (Intersection ?X ?Y))
;        (= ?expr2 (Empty))
;        (union ?expr1 ?expr2)))

; Singleton operations (DEFERRED - Union/Intersection not in core focus)
; (rewrite (Union (Singleton ?x) (Singleton ?x))
;          (Singleton ?x))

; (rewrite (Intersection (Singleton ?x) (Singleton ?x))
;          (Singleton ?x))

; ========================================
; CONSTANT PROPAGATION RULES
; ========================================

; Basic arithmetic constant propagation
(rule ((= ?x (Num ?a)) (= ?y (Num ?b)))
      ((union (Add ?x ?y) (Num (+ ?a ?b)))))

(rule ((= ?x (Num ?a)) (= ?y (Num ?b)))
      ((union (Mul ?x ?y) (Num (* ?a ?b)))))

(rule ((= ?x (Num ?a)) (= ?y (Num ?b)) (!= ?b 0.0))
      ((union (Div ?x ?y) (Num (/ ?a ?b)))))

; Sum constant propagation for simple ranges
(rule ((= ?start (Num ?s)) (= ?end (Num ?e)) (<= ?s ?e))
      ((union (Sum (Range ?start ?end) (Identity))
              (Num (/ (* (+ ?e ?s) (- ?e ?s -1.0)) 2.0)))))

; Size constant propagation
(rule ((= ?start (Num ?s)) (= ?end (Num ?e)) (<= ?s ?e))
      ((union (Size (Range ?start ?end))
              (Num (- ?e ?s -1.0))))) 