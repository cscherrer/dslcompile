; Common Subexpression Elimination (CSE) Rules - Structural Version
; Uses egglog's built-in equality saturation for proper CSE
; 
; This approach leverages egglog's structural equality to identify and factor
; common subexpressions without hardcoded binding IDs or collision risks.

; ========================================
; STRUCTURAL CSE APPROACH  
; ========================================

; Note: ruleset cse_rules is declared in staged_core_math.egg

; Key Insight: Instead of manually assigning binding IDs, let egglog's 
; equality saturation discover structural equivalences and create canonical
; forms through bidirectional rewrite rules.

; ========================================
; CANONICAL FORM RULES
; ========================================

; Canonical form: x * x → x^2 (more canonical for CSE analysis)
(rewrite (Mul ?x ?x) (Pow ?x (Num 2.0)) :ruleset cse_rules)

; Canonical form: x + x → 2*x (more canonical for CSE analysis)  
(rewrite (Add ?x ?x) (Mul (Num 2.0) ?x) :ruleset cse_rules)

; Canonical form: x / x → 1 (when safe)
(rewrite (Div ?x ?x) (Num 1.0) :ruleset cse_rules)

; ========================================
; FACTORIZATION-BASED CSE 
; ========================================

; Factor common subexpressions in addition
; a*c + b*c → (a + b)*c
(rewrite (Add (Mul ?a ?shared) (Mul ?b ?shared))
         (Mul (Add ?a ?b) ?shared)
         :ruleset cse_rules)

; Factor common subexpressions in multiplication
; (a + b) * (a + b) → (a + b)^2  
(rewrite (Mul ?shared ?shared) (Pow ?shared (Num 2.0)) :ruleset cse_rules)

; Factor common divisors
; a/c + b/c → (a + b)/c
(rewrite (Add (Div ?a ?shared) (Div ?b ?shared))
         (Div (Add ?a ?b) ?shared)
         :ruleset cse_rules)

; ========================================
; SPECIFIC HIGH-VALUE PATTERNS
; ========================================

; Gaussian standardization pattern: ((x-μ)/σ)² 
; This is the exact pattern causing 2x performance loss in probabilistic programming
(rewrite (Mul (Div (Add ?x (Neg ?mu)) ?sigma) (Div (Add ?x (Neg ?mu)) ?sigma))
         (Pow (Div (Add ?x (Neg ?mu)) ?sigma) (Num 2.0))
         :ruleset cse_rules)

; Extended Gaussian patterns for log-likelihood
; log(σ) + 0.5*log(2π) + 0.5*((x-μ)/σ)² common subexpressions
(rewrite (Add (Ln ?sigma) (Mul (Num 0.5) (Pow (Div (Add ?x (Neg ?mu)) ?sigma) (Num 2.0))))
         (Add (Ln ?sigma) (Mul (Num 0.5) (Pow (Div (Add ?x (Neg ?mu)) ?sigma) (Num 2.0))))
         :ruleset cse_rules)

; ========================================
; EXPRESSION NORMALIZATION FOR BETTER CSE
; ========================================

; Normalize multiplication order for better pattern matching
; This helps CSE recognize (a*b) and (b*a) as the same
(rewrite (Mul ?a ?b) (Mul ?b ?a) :ruleset cse_rules)

; Normalize addition order for better pattern matching  
(rewrite (Add ?a ?b) (Add ?b ?a) :ruleset cse_rules)

; Associate operations to expose more CSE opportunities
; (a + b) + c → a + (b + c) - this can expose hidden common subexpressions
(rewrite (Add (Add ?a ?b) ?c) (Add ?a (Add ?b ?c)) :ruleset cse_rules)
(rewrite (Mul (Mul ?a ?b) ?c) (Mul ?a (Mul ?b ?c)) :ruleset cse_rules)

; ========================================
; COMPOUND EXPRESSION CSE
; ========================================

; Recognize repeated polynomial patterns
; (a + b)*(c + d) + (a + b)*(e + f) → (a + b)*((c + d) + (e + f))
(rewrite (Add (Mul ?shared (Add ?c ?d)) (Mul ?shared (Add ?e ?f)))
         (Mul ?shared (Add (Add ?c ?d) (Add ?e ?f)))
         :ruleset cse_rules)

; Recognize repeated transcendental patterns  
; sin(x) + cos(x) patterns, exp(x) patterns, etc.
(rewrite (Add (Sin ?x) (Mul ?c (Sin ?x)))
         (Mul (Add (Num 1.0) ?c) (Sin ?x))
         :ruleset cse_rules)

(rewrite (Add (Exp ?x) (Mul ?c (Exp ?x)))
         (Mul (Add (Num 1.0) ?c) (Exp ?x))
         :ruleset cse_rules)

; ========================================
; ADVANTAGES OF STRUCTURAL APPROACH
; ========================================

; 1. NO COLLISION RISK: Uses egglog's built-in equality, no manual IDs
; 2. CANONICAL FORMS: Leverages mathematical identities for recognition  
; 3. BIDIRECTIONAL: Rewrite rules work in both directions automatically
; 4. EXTENSIBLE: Easy to add new patterns without ID management
; 5. MATHEMATICALLY SOUND: Based on proven algebraic identities
; 6. COMPOSABLE: Works with other optimization phases naturally

; Example transformations:
; BEFORE: Mul(Div(Add(x,Neg(mu)),sigma), Div(Add(x,Neg(mu)),sigma))  
; AFTER:  Pow(Div(Add(x,Neg(mu)),sigma), Num(2.0))
;
; BEFORE: Add(Mul(shared, a), Mul(shared, b))
; AFTER:  Mul(shared, Add(a, b))
;
; This approach eliminates redundant computation through mathematical 
; identity recognition rather than ad-hoc binding ID assignment!

; ========================================
; INTEGRATION WITH COST MODEL
; ========================================

; The cost model in core_datatypes.egg will automatically prefer 
; canonical forms that reduce operation count:
; - Pow(x, 2.0) is cheaper than Mul(x, x) when x is complex
; - Mul(shared, Add(a, b)) is cheaper than Add(Mul(shared, a), Mul(shared, b))
; - Canonical forms expose more optimization opportunities

; ========================================
; DEBUGGING AND VERIFICATION
; ========================================

; To verify CSE is working:
; 1. Check that expressions with repeated subexpressions get factored
; 2. Verify that canonical forms are consistently applied  
; 3. Measure operation count reduction in extracted expressions
; 4. Test with Gaussian log-likelihood patterns specifically

; This approach is mathematically principled, collision-free, and extensible! 