; Clean Summation Rules - Production Ready
; Focused on the two key optimizations without conflicts

; Basic math expressions
(datatype Math
  (Num f64)
  (Var i64)  ; Integer variable indices
  (Add Math Math)
  (Mul Math Math)
  (Sub Math Math)
)

; Collection types 
(datatype Collection
  (Empty)                           ; Empty collection
  (Singleton Math)                  ; Single element collection  
  (Range Math Math)                 ; Mathematical range [start, end]
  (DataArray i64)                   ; Data array by index
)

; Lambda expressions
(datatype Lambda
  (LambdaFunc i64 Math)            ; lambda var_index -> body
  (Identity)                       ; lambda x -> x  
  (ConstantFunc Math)              ; lambda x -> constant
)

; Cross-datatype constructors
(constructor Sum (Collection) Math)  ; Sum over a collection
(constructor Map (Lambda Collection) Collection)  ; Map function over collection

; ========================================
; ESSENTIAL CONSTANT FOLDING
; ========================================

(rewrite (Add (Num ?a) (Num ?b)) (Num (+ ?a ?b)))
(rewrite (Mul (Num ?a) (Num ?b)) (Num (* ?a ?b)))
(rewrite (Sub (Num ?a) (Num ?b)) (Num (- ?a ?b)))

; Identity rules
(rewrite (Add (Num 0.0) ?x) ?x)
(rewrite (Mul (Num 1.0) ?x) ?x)
(rewrite (Mul (Num 0.0) ?x) (Num 0.0))

; Variable collection (integer indices)
(rewrite (Add (Var ?v) (Var ?v)) (Mul (Num 2.0) (Var ?v)))
(rewrite (Add (Mul (Num ?a) (Var ?v)) (Mul (Num ?b) (Var ?v)))
         (Mul (Num (+ ?a ?b)) (Var ?v)))

; ========================================
; CORE COLLECTION RULES
; ========================================

(rewrite (Sum (Empty)) (Num 0.0))
(rewrite (Sum (Singleton ?expr)) ?expr)

; ========================================
; KEY OPTIMIZATIONS (User's Priority)
; ========================================

; 1. Sum splitting: Σ(f + g) = Σ(f) + Σ(g)
(rewrite (Sum (Map (LambdaFunc ?var (Add ?f ?g)) ?collection))
         (Add (Sum (Map (LambdaFunc ?var ?f) ?collection))
              (Sum (Map (LambdaFunc ?var ?g) ?collection))))

; 2. Constant factor: Σ(k * f) = k * Σ(f)
(rewrite (Sum (Map (LambdaFunc ?var (Mul ?k ?f)) ?collection))
         (Mul ?k (Sum (Map (LambdaFunc ?var ?f) ?collection))))

; ========================================
; LAMBDA RULES
; ========================================

(rewrite (Map (Identity) ?collection) ?collection)
(rewrite (LambdaFunc ?var (Var ?var)) (Identity))
(rewrite (LambdaFunc ?var (Num ?c)) (ConstantFunc (Num ?c)))

; ========================================
; DIRECT CONSTANT EVALUATION (No Conflicts)
; ========================================

; Direct range sums (specific cases)
(rewrite (Sum (Range (Num 1.0) (Num 2.0))) (Num 3.0))   ; 1+2=3
(rewrite (Sum (Range (Num 1.0) (Num 3.0))) (Num 6.0))   ; 1+2+3=6
(rewrite (Sum (Range (Num 1.0) (Num 4.0))) (Num 10.0))  ; 1+2+3+4=10
(rewrite (Sum (Range (Num 1.0) (Num 5.0))) (Num 15.0))  ; 1+2+3+4+5=15

; Constant map over range: Σ(c for i in range) = c * range_size
(rewrite (Sum (Map (ConstantFunc ?c) (Range (Num 1.0) (Num 2.0))))
         (Mul ?c (Num 2.0)))
(rewrite (Sum (Map (ConstantFunc ?c) (Range (Num 1.0) (Num 3.0))))
         (Mul ?c (Num 3.0)))
(rewrite (Sum (Map (ConstantFunc ?c) (Range (Num 1.0) (Num 4.0))))
         (Mul ?c (Num 4.0))) 