; ========================================
; CLEAN SUMMATION RULES FOR DSLCOMPILE
; ========================================
; Production-ready summation optimization rules with dependency analysis
; Implements sum splitting: Σ(f + g) → Σ(f) + Σ(g)
; and coefficient factoring: Σ(c * f) → c * Σ(f) when c is independent

; ========================================
; BASIC SUM SPLITTING RULES
; ========================================

; Sum of addition splits into sum of terms
; Rule: Sum(Map(LambdaFunc(var, Add(f, g)), collection)) → Add(Sum(Map(LambdaFunc(var, f), collection)), Sum(Map(LambdaFunc(var, g), collection)))
(rewrite (Sum (Map (LambdaFunc ?var (Add ?f ?g)) ?collection))
         (Add (Sum (Map (LambdaFunc ?var ?f) ?collection))
              (Sum (Map (LambdaFunc ?var ?g) ?collection))))

; Sum of subtraction splits into difference of sums  
; Rule: Sum(Map(LambdaFunc(var, Sub(f, g)), collection)) → Sub(Sum(Map(LambdaFunc(var, f), collection)), Sum(Map(LambdaFunc(var, g), collection)))
(rewrite (Sum (Map (LambdaFunc ?var (Sub ?f ?g)) ?collection))
         (Sub (Sum (Map (LambdaFunc ?var ?f) ?collection))
              (Sum (Map (LambdaFunc ?var ?g) ?collection))))

; ========================================
; COEFFICIENT FACTORING RULES
; ========================================

; Factor out constant multipliers
; Rule: Sum(Map(LambdaFunc(var, Mul(c, f)), collection)) → Mul(c, Sum(Map(LambdaFunc(var, f), collection)))
; when c is independent of var (doesn't contain BoundVar(var))
(rewrite (Sum (Map (LambdaFunc ?var (Mul ?coeff ?term)) ?collection))
         (Mul ?coeff (Sum (Map (LambdaFunc ?var ?term) ?collection)))
         :when ((is-independent-of ?coeff ?var)))

; Factor out constant multipliers (commutative case)
; Rule: Sum(Map(LambdaFunc(var, Mul(f, c)), collection)) → Mul(c, Sum(Map(LambdaFunc(var, f), collection)))
; when c is independent of var
(rewrite (Sum (Map (LambdaFunc ?var (Mul ?term ?coeff)) ?collection))
         (Mul ?coeff (Sum (Map (LambdaFunc ?var ?term) ?collection)))
         :when ((is-independent-of ?coeff ?var)))

; ========================================
; CONSTANT TERM FACTORING
; ========================================

; Sum of constants becomes constant times collection size
; For now, handle specific collection patterns

; Sum of constants over Range
(rewrite (Sum (Map (ConstantFunc ?c) (Range ?start ?end)))
         (Mul ?c (Add (Sub ?end ?start) (Num 1.0))))

; Sum of constants over Singleton
(rewrite (Sum (Map (ConstantFunc ?c) (Singleton ?elem)))
         ?c)

; Sum of constants over Empty collection
(rewrite (Sum (Map (ConstantFunc ?c) (Empty)))
         (Num 0.0))

; ========================================
; IDENTITY AND SIMPLIFICATION RULES
; ========================================

; Identity lambda can be eliminated
(rewrite (Sum (Map (Identity) ?collection))
         (Sum ?collection))

; Nested lambda composition simplification
; Map(LambdaFunc(var, expr), Map(f, collection)) patterns would go here
; For now, focus on the basic cases

; ========================================
; ADVANCED FACTORING PATTERNS  
; ========================================

; Factor out division by constants
; Rule: Sum(Map(LambdaFunc(var, Div(f, c)), collection)) → Div(Sum(Map(LambdaFunc(var, f), collection)), c)
; when c is independent of var and non-zero
(rewrite (Sum (Map (LambdaFunc ?var (Div ?term ?coeff)) ?collection))
         (Div (Sum (Map (LambdaFunc ?var ?term) ?collection)) ?coeff)
         :when ((is-independent-of ?coeff ?var)))

; Factor out power with constant exponent
; Rule: Sum(Map(LambdaFunc(var, Pow(f, c)), collection)) patterns
; More complex - requires careful analysis of when this is valid

; ========================================
; COLLECTION COMBINATION RULES
; ========================================

; Combine sums over the same collection with different functions
; Sum(Map(f, collection)) + Sum(Map(g, collection)) → Sum(Map(LambdaFunc(var, f(var) + g(var)), collection))
; This is the reverse of sum splitting - useful for cleanup

; Note: These reverse rules would create cycles, so they need careful cost modeling
; or to be in a separate optimization phase

; ========================================
; DEPENDENCY-SAFE OPTIMIZATION RULES
; ========================================

; These rules only fire when dependency analysis confirms they're safe
; The is-independent-of function is computed by the dependency analysis system

; Nested multiplication factoring
; Sum(Map(LambdaFunc(var, Mul(Mul(c1, c2), f)), collection)) → Mul(Mul(c1, c2), Sum(Map(LambdaFunc(var, f), collection)))
; when both c1 and c2 are independent of var
(rewrite (Sum (Map (LambdaFunc ?var (Mul (Mul ?c1 ?c2) ?term)) ?collection))
         (Mul (Mul ?c1 ?c2) (Sum (Map (LambdaFunc ?var ?term) ?collection)))
         :when ((is-independent-of ?c1 ?var)
                (is-independent-of ?c2 ?var)))

; Complex coefficient patterns
; Sum(Map(LambdaFunc(var, Mul(Add(c1, c2), f)), collection)) → Mul(Add(c1, c2), Sum(Map(LambdaFunc(var, f), collection)))
; when the entire expression Add(c1, c2) is independent of var
(rewrite (Sum (Map (LambdaFunc ?var (Mul (Add ?c1 ?c2) ?term)) ?collection))
         (Mul (Add ?c1 ?c2) (Sum (Map (LambdaFunc ?var ?term) ?collection)))
         :when ((is-independent-of (Add ?c1 ?c2) ?var)))

; ========================================
; RULESET ORGANIZATION
; ========================================

; Create rulesets for different optimization phases
(ruleset sum_splitting)
(ruleset coefficient_factoring)
(ruleset collection_simplification)

; Basic sum splitting rules
(rewrite (Sum (Map (LambdaFunc ?var (Add ?f ?g)) ?collection))
         (Add (Sum (Map (LambdaFunc ?var ?f) ?collection))
              (Sum (Map (LambdaFunc ?var ?g) ?collection)))
         :ruleset sum_splitting)

; Safe coefficient factoring rules  
(rewrite (Sum (Map (LambdaFunc ?var (Mul ?coeff ?term)) ?collection))
         (Mul ?coeff (Sum (Map (LambdaFunc ?var ?term) ?collection)))
         :when ((is-independent-of ?coeff ?var))
         :ruleset coefficient_factoring)

; ========================================
; OPTIMIZATION STRATEGY NOTES
; ========================================

; The rules in this file implement a staged optimization approach:
; 1. First apply sum_splitting to break apart complex summations
; 2. Then apply coefficient_factoring to extract independent terms  
; 3. Finally apply collection_simplification to clean up the results

; All factoring rules depend on the dependency analysis system to ensure safety.
; The is-independent-of predicate is computed automatically based on variable usage analysis.

; This approach ensures mathematical correctness while enabling powerful optimizations
; like: Σ(a*x + b*x + c) → a*Σ(x) + b*Σ(x) + c*n → (a+b)*Σ(x) + c*n