; ========================================
; MINIMAL DEPENDENCY ANALYSIS FOR DSLCOMPILE
; ========================================
; Essential dependency tracking for safe optimizations
; Keeps only the core VarSet functionality without complex Bool predicates

; ========================================
; VARIABLE DEPENDENCY TRACKING SYSTEM
; ========================================

; Set of variable indices for dependency tracking
(datatype VarSet
  (EmptySet)                         ; No dependencies
  (SingleVar i64)                    ; Single variable dependency  
  (UnionSet VarSet VarSet)           ; Union of two dependency sets
)

; ========================================
; CORE DEPENDENCY FUNCTIONS  
; ========================================

; Track which variables are used in each expression
(function free-vars (Math) VarSet :merge (UnionSet old new))

; ========================================
; BASIC DEPENDENCY RULES
; ========================================

; Constants have no dependencies - use specific values to avoid unbound variables
(rule () ((set (free-vars (Num 0.0)) (EmptySet))))
(rule () ((set (free-vars (Num 1.0)) (EmptySet))))
(rule () ((set (free-vars (Num 2.0)) (EmptySet))))

; UserVars contribute their index to free variables
(rule () ((set (free-vars (UserVar ?v)) (SingleVar ?v))))

; BoundVars are not free (they're bound by Let constructs)
(rule () ((set (free-vars (BoundVar ?id)) (EmptySet))))

; Binary operations union dependencies from both operands
(rule () ((set (free-vars (Add ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Mul ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Div ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Pow ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))

; Unary operations inherit dependencies from operand
(rule () ((set (free-vars (Neg ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Ln ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Exp ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Sin ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Cos ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Sqrt ?a)) (free-vars ?a))))

; Let bindings union dependencies from expression and body
(rule () ((set (free-vars (Let ?id ?expr ?body)) 
               (UnionSet (free-vars ?expr) (free-vars ?body)))))

; Sum operations depend on collection dependencies  
(rule () ((set (free-vars (Sum ?collection)) (collection-deps ?collection))))

; ========================================
; COLLECTION DEPENDENCIES
; ========================================

(function collection-deps (Collection) VarSet :merge (UnionSet old new))

(rule () ((set (collection-deps (Empty)) (EmptySet))))
(rule () ((set (collection-deps (Singleton ?expr)) (free-vars ?expr))))
(rule () ((set (collection-deps (Range ?start ?end)) 
               (UnionSet (free-vars ?start) (free-vars ?end)))))
(rule () ((set (collection-deps (DataArray ?id)) (EmptySet))))

; ========================================
; SAFE OPTIMIZATION RULESETS
; ========================================

; Create a ruleset for dependency-aware optimizations
; (These would be expansion points for future safe optimization rules)
(ruleset dependency_analysis)
(ruleset safe_optimizations)

; The dependency analysis rules themselves
(rule () ((set (free-vars (Num ?c)) (EmptySet))) :ruleset dependency_analysis)
(rule () ((set (free-vars (UserVar ?v)) (SingleVar ?v))) :ruleset dependency_analysis)
(rule () ((set (free-vars (BoundVar ?id)) (EmptySet))) :ruleset dependency_analysis)

; Note: Additional safe optimization rules would go in safe_optimizations ruleset
; They would check dependencies before applying transformations
; For now, we'll add rules only when specific examples need them 