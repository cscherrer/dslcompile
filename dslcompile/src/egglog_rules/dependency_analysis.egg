; ========================================
; DEPENDENCY ANALYSIS FOR DSLCOMPILE - AVOIDING CIRCULAR DEPENDENCIES
; ========================================
; Uses strategies from egglog cheatsheet:
; - Strategy #4: Defer Function Evaluation
; - Strategy #6: Separate Definition from Computation
; - Strategy #1: Hierarchical Function Organization

; ========================================
; RULESETS DECLARATION (MUST BE FIRST!)
; ========================================

; Create rulesets for controlled optimization phases - declare early!
(ruleset dependency_analysis)
(ruleset safe_optimizations)

; ========================================
; BASIC DATATYPES
; ========================================

; Set of variable indices for dependency tracking
(datatype VarSet
  (EmptySet)                         ; No dependencies
  (SingleVar i64)                    ; Single variable dependency  
  (UnionSet VarSet VarSet)           ; Union of two dependency sets
)

; ========================================
; STEP 1: DEFINE ALL FUNCTION SIGNATURES FIRST
; ========================================
; Strategy #6: Separate Definition from Computation

; Base layer - no dependencies on other functions
(function free-vars (Math) VarSet :merge (UnionSet old new))
(function collection-deps (Collection) VarSet :merge (UnionSet old new))
(function lambda-deps (Lambda) VarSet :merge (UnionSet old new))

; ========================================
; STEP 2: DEFER COMPUTATION USING RELATIONS
; ========================================
; Strategy #4: Defer Function Evaluation

; Relations to stage computation and avoid circular dependencies
(relation compute-free-vars (Math))
(relation free-vars-ready (Math VarSet))
(relation compute-collection-deps (Collection))
(relation collection-deps-ready (Collection VarSet))
(relation compute-lambda-deps (Lambda))
(relation lambda-deps-ready (Lambda VarSet))

; ========================================
; STEP 3: BASE LAYER COMPUTATION (NO DEPENDENCIES)
; ========================================
; Strategy #1: Hierarchical Function Organization

; Base cases - compute immediately for leaf nodes
(rule ((Num ?c))
      ((free-vars-ready (Num ?c) (EmptySet))))

(rule ((UserVar ?v))
      ((free-vars-ready (UserVar ?v) (SingleVar ?v))))

(rule ((BoundVar ?id))
      ((free-vars-ready (BoundVar ?id) (EmptySet))))

; Base collection cases
(rule ((Empty))
      ((collection-deps-ready (Empty) (EmptySet))))

(rule ((DataArray ?id))
      ((collection-deps-ready (DataArray ?id) (EmptySet))))

; Base lambda cases  
(rule ((Identity))
      ((lambda-deps-ready (Identity) (EmptySet))))

; ========================================
; STEP 4: DEMAND-DRIVEN COMPUTATION REQUESTS
; ========================================
; Strategy #5: Use Demand-Driven Computation

; Request computation for composite expressions
(rule ((Add ?a ?b))
      ((compute-free-vars ?a)
       (compute-free-vars ?b)
       (compute-free-vars (Add ?a ?b))))

(rule ((Mul ?a ?b))
      ((compute-free-vars ?a)
       (compute-free-vars ?b)
       (compute-free-vars (Mul ?a ?b))))

(rule ((Sub ?a ?b))
      ((compute-free-vars ?a)
       (compute-free-vars ?b)
       (compute-free-vars (Sub ?a ?b))))

(rule ((Div ?a ?b))
      ((compute-free-vars ?a)
       (compute-free-vars ?b)
       (compute-free-vars (Div ?a ?b))))

(rule ((Pow ?a ?b))
      ((compute-free-vars ?a)
       (compute-free-vars ?b)
       (compute-free-vars (Pow ?a ?b))))

; Unary operations
(rule ((Neg ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Neg ?a))))

(rule ((Ln ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Ln ?a))))

(rule ((Exp ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Exp ?a))))

(rule ((Sin ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Sin ?a))))

(rule ((Cos ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Cos ?a))))

(rule ((Sqrt ?a))
      ((compute-free-vars ?a)
       (compute-free-vars (Sqrt ?a))))

; Let expressions
(rule ((Let ?id ?expr ?body))
      ((compute-free-vars ?expr)
       (compute-free-vars ?body)
       (compute-free-vars (Let ?id ?expr ?body))))

; Sum expressions
(rule ((Sum ?collection))
      ((compute-collection-deps ?collection)
       (compute-free-vars (Sum ?collection))))

; ========================================
; STEP 5: STAGED COMPUTATION WHEN DEPENDENCIES ARE READY
; ========================================

; Binary operations - compute when both operands are ready
(rule ((compute-free-vars (Add ?a ?b))
       (free-vars-ready ?a ?dep_a)
       (free-vars-ready ?b ?dep_b))
      ((free-vars-ready (Add ?a ?b) (UnionSet ?dep_a ?dep_b))))

(rule ((compute-free-vars (Mul ?a ?b))
       (free-vars-ready ?a ?dep_a)
       (free-vars-ready ?b ?dep_b))
      ((free-vars-ready (Mul ?a ?b) (UnionSet ?dep_a ?dep_b))))

(rule ((compute-free-vars (Sub ?a ?b))
       (free-vars-ready ?a ?dep_a)
       (free-vars-ready ?b ?dep_b))
      ((free-vars-ready (Sub ?a ?b) (UnionSet ?dep_a ?dep_b))))

(rule ((compute-free-vars (Div ?a ?b))
       (free-vars-ready ?a ?dep_a)
       (free-vars-ready ?b ?dep_b))
      ((free-vars-ready (Div ?a ?b) (UnionSet ?dep_a ?dep_b))))

(rule ((compute-free-vars (Pow ?a ?b))
       (free-vars-ready ?a ?dep_a)
       (free-vars-ready ?b ?dep_b))
      ((free-vars-ready (Pow ?a ?b) (UnionSet ?dep_a ?dep_b))))

; Unary operations - compute when operand is ready
(rule ((compute-free-vars (Neg ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Neg ?a) ?dep_a)))

(rule ((compute-free-vars (Ln ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Ln ?a) ?dep_a)))

(rule ((compute-free-vars (Exp ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Exp ?a) ?dep_a)))

(rule ((compute-free-vars (Sin ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Sin ?a) ?dep_a)))

(rule ((compute-free-vars (Cos ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Cos ?a) ?dep_a)))

(rule ((compute-free-vars (Sqrt ?a))
       (free-vars-ready ?a ?dep_a))
      ((free-vars-ready (Sqrt ?a) ?dep_a)))

; Let expressions - compute when both expr and body are ready
(rule ((compute-free-vars (Let ?id ?expr ?body))
       (free-vars-ready ?expr ?dep_expr)
       (free-vars-ready ?body ?dep_body))
      ((free-vars-ready (Let ?id ?expr ?body) (UnionSet ?dep_expr ?dep_body))))

; Sum expressions - compute when collection dependencies are ready
(rule ((compute-free-vars (Sum ?collection))
       (collection-deps-ready ?collection ?dep_coll))
      ((free-vars-ready (Sum ?collection) ?dep_coll)))

; ========================================
; STEP 6: FINALIZE FUNCTION VALUES
; ========================================

; Set function values when computation is ready
(rule ((free-vars-ready ?expr ?deps))
      ((set (free-vars ?expr) ?deps)))

; ========================================
; COLLECTION DEPENDENCY STAGING
; ========================================

; Request computation for collections that depend on expressions
(rule ((Singleton ?expr))
      ((compute-free-vars ?expr)
       (compute-collection-deps (Singleton ?expr))))

(rule ((Range ?start ?end))
      ((compute-free-vars ?start)
       (compute-free-vars ?end)
       (compute-collection-deps (Range ?start ?end))))

; Compute collection dependencies when expressions are ready
(rule ((compute-collection-deps (Singleton ?expr))
       (free-vars-ready ?expr ?dep_expr))
      ((collection-deps-ready (Singleton ?expr) ?dep_expr)))

(rule ((compute-collection-deps (Range ?start ?end))
       (free-vars-ready ?start ?dep_start)
       (free-vars-ready ?end ?dep_end))
      ((collection-deps-ready (Range ?start ?end) (UnionSet ?dep_start ?dep_end))))

; Set collection function values when ready
(rule ((collection-deps-ready ?coll ?deps))
      ((set (collection-deps ?coll) ?deps)))

; ========================================
; LAMBDA DEPENDENCY COMPUTATION
; ========================================

; Request computation for lambdas that depend on expressions
(rule ((ConstantFunc ?expr))
      ((compute-free-vars ?expr)
       (compute-lambda-deps (ConstantFunc ?expr))))

(rule ((LambdaFunc ?var ?expr))
      ((compute-free-vars ?expr)
       (compute-lambda-deps (LambdaFunc ?var ?expr))))

; Compute lambda dependencies when expressions are ready
(rule ((compute-lambda-deps (ConstantFunc ?expr))
       (free-vars-ready ?expr ?dep_expr))
      ((lambda-deps-ready (ConstantFunc ?expr) ?dep_expr)))

(rule ((compute-lambda-deps (LambdaFunc ?var ?expr))
       (free-vars-ready ?expr ?dep_expr))
      ((lambda-deps-ready (LambdaFunc ?var ?expr) ?dep_expr)))

; Set lambda function values when ready
(rule ((lambda-deps-ready ?lambda ?deps))
      ((set (lambda-deps ?lambda) ?deps)))

; ========================================
; INDEPENDENCE CHECKING (SIMPLIFIED)
; ========================================

; Simple independence relation for optimization rules
(relation is-independent-of (Math i64))

; UserVars are independent of bound variables (different scopes)
(rule ((UserVar ?idx))
      ((is-independent-of (UserVar ?idx) 0)
       (is-independent-of (UserVar ?idx) 1)
       (is-independent-of (UserVar ?idx) 2)))

; Constants are independent of all variables
(rule ((Num ?val))
      ((is-independent-of (Num ?val) 0)
       (is-independent-of (Num ?val) 1)
       (is-independent-of (Num ?val) 2)))

; ========================================
; RULESETS FOR PHASED OPTIMIZATION
; ========================================

; The main dependency analysis rules above run without rulesets to ensure
; they're always active. The rulesets were declared at the top of this file.

; Constructor for factored lambda expressions (if needed for optimization rules)
(constructor FactoredLambda (Math Lambda) Lambda)