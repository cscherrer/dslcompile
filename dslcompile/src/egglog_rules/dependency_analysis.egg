; ========================================
; DEPENDENCY ANALYSIS SYSTEM FOR DSLCOMPILE
; ========================================
; Implements grammar-embedded dependency analysis to eliminate variable capture bugs
; and enable safer optimization rules. Integrates with staged_core_math.egg.

; ========================================
; BASIC DATATYPES
; ========================================

; Boolean type for dependency checking
(datatype Bool
  (true)
  (false)
)

; ========================================
; VARIABLE DEPENDENCY TRACKING SYSTEM
; ========================================

; Set of variable indices for dependency tracking
(datatype VarSet
  (EmptySet)                         ; No dependencies
  (SingleVar i64)                    ; Single variable dependency  
  (UnionSet VarSet VarSet)           ; Union of two dependency sets
)

; ========================================
; DEPENDENCY FUNCTIONS
; ========================================

; Core dependency analysis functions - computed automatically from structure
(function free-vars (Math) VarSet :merge (UnionSet old new))
(function bound-vars (Math) VarSet :merge (UnionSet old new))
(function contains-var (VarSet i64) Bool :merge (or old new))
(function is-independent-of (Math i64) Bool :merge (or old new))

; ========================================
; BASIC DEPENDENCY COMPUTATION RULES
; ========================================

; Constants have no dependencies
(set (free-vars (Num 0.0)) (EmptySet))
(set (free-vars (Num 1.0)) (EmptySet))
(set (free-vars (Num 2.0)) (EmptySet))

; UserVars contribute their index to free vars (external variables)
(set (free-vars (UserVar 0)) (SingleVar 0))
(set (free-vars (UserVar 1)) (SingleVar 1))
(set (free-vars (UserVar 2)) (SingleVar 2))

; BoundVars are not free (they're bound by lambda or let)
(set (free-vars (BoundVar 0)) (EmptySet))
(set (free-vars (BoundVar 1)) (EmptySet))
(set (free-vars (BoundVar 2)) (EmptySet))

; Constants have no bound variables
(set (bound-vars (Num 0.0)) (EmptySet))
(set (bound-vars (Num 1.0)) (EmptySet))
(set (bound-vars (Num 2.0)) (EmptySet))

; External variables are not bound
(set (bound-vars (UserVar 0)) (EmptySet))
(set (bound-vars (UserVar 1)) (EmptySet))
(set (bound-vars (UserVar 2)) (EmptySet))

; BoundVars contribute their index to bound vars
(set (bound-vars (BoundVar 0)) (SingleVar 0))
(set (bound-vars (BoundVar 1)) (SingleVar 1))
(set (bound-vars (BoundVar 2)) (SingleVar 2))

; ========================================
; COMPOSITIONAL DEPENDENCY RULES
; ========================================

; Binary operations union dependencies from both operands
(rule () ((set (free-vars (Add ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Mul ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Div ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))
(rule () ((set (free-vars (Pow ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))

(rule () ((set (bound-vars (Add ?a ?b)) (UnionSet (bound-vars ?a) (bound-vars ?b)))))
(rule () ((set (bound-vars (Mul ?a ?b)) (UnionSet (bound-vars ?a) (bound-vars ?b)))))
(rule () ((set (bound-vars (Div ?a ?b)) (UnionSet (bound-vars ?a) (bound-vars ?b)))))
(rule () ((set (bound-vars (Pow ?a ?b)) (UnionSet (bound-vars ?a) (bound-vars ?b)))))

; Unary operations inherit dependencies from operand
(rule () ((set (free-vars (Neg ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Ln ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Exp ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Sin ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Cos ?a)) (free-vars ?a))))
(rule () ((set (free-vars (Sqrt ?a)) (free-vars ?a))))

(rule () ((set (bound-vars (Neg ?a)) (bound-vars ?a))))
(rule () ((set (bound-vars (Ln ?a)) (bound-vars ?a))))
(rule () ((set (bound-vars (Exp ?a)) (bound-vars ?a))))
(rule () ((set (bound-vars (Sin ?a)) (bound-vars ?a))))
(rule () ((set (bound-vars (Cos ?a)) (bound-vars ?a))))
(rule () ((set (bound-vars (Sqrt ?a)) (bound-vars ?a))))

; Let binding dependency rules
(rule () ((set (free-vars (Let ?id ?expr ?body)) 
               (UnionSet (free-vars ?expr) 
                        (free-vars ?body)))))

(rule () ((set (bound-vars (Let ?id ?expr ?body)) 
               (UnionSet (bound-vars ?expr) 
                        (UnionSet (bound-vars ?body) (SingleVar ?id))))))

; Summation dependency rules
(rule () ((set (free-vars (Sum ?collection)) (free-vars-collection ?collection))))
(rule () ((set (bound-vars (Sum ?collection)) (bound-vars-collection ?collection))))

; ========================================
; COLLECTION DEPENDENCY RULES
; ========================================

; Collection dependency functions
(function free-vars-collection (Collection) VarSet :merge (UnionSet old new))
(function bound-vars-collection (Collection) VarSet :merge (UnionSet old new))

; Empty collections have no dependencies
(set (free-vars-collection (Empty)) (EmptySet))
(set (bound-vars-collection (Empty)) (EmptySet))

; Singleton collections inherit from their element
(rule () ((set (free-vars-collection (Singleton ?expr)) (free-vars ?expr))))
(rule () ((set (bound-vars-collection (Singleton ?expr)) (bound-vars ?expr))))

; Range collections union dependencies from start and end
(rule () ((set (free-vars-collection (Range ?start ?end)) 
               (UnionSet (free-vars ?start) (free-vars ?end)))))
(rule () ((set (bound-vars-collection (Range ?start ?end)) 
               (UnionSet (bound-vars ?start) (bound-vars ?end)))))

; DataArray collections have no dependencies (they're external data)
(set (free-vars-collection (DataArray 0)) (EmptySet))
(set (free-vars-collection (DataArray 1)) (EmptySet))
(set (free-vars-collection (DataArray 2)) (EmptySet))
(set (bound-vars-collection (DataArray 0)) (EmptySet))
(set (bound-vars-collection (DataArray 1)) (EmptySet))
(set (bound-vars-collection (DataArray 2)) (EmptySet))

; Map collections union dependencies from lambda and collection
(rule () ((set (free-vars-collection (Map ?lambda ?collection)) 
               (UnionSet (free-vars-lambda ?lambda) (free-vars-collection ?collection)))))
(rule () ((set (bound-vars-collection (Map ?lambda ?collection)) 
               (UnionSet (bound-vars-lambda ?lambda) (bound-vars-collection ?collection)))))

; ========================================
; LAMBDA DEPENDENCY RULES
; ========================================

; Lambda dependency functions
(function free-vars-lambda (Lambda) VarSet :merge (UnionSet old new))
(function bound-vars-lambda (Lambda) VarSet :merge (UnionSet old new))

; LambdaFunc dependencies - body dependencies minus the bound variable
(rule () ((set (free-vars-lambda (LambdaFunc ?var ?body)) 
               (free-vars ?body))))  ; The lambda parameter is not counted as free
(rule () ((set (bound-vars-lambda (LambdaFunc ?var ?body)) 
               (UnionSet (bound-vars ?body) (SingleVar ?var)))))

; Identity lambda has no dependencies
(set (free-vars-lambda (Identity)) (EmptySet))
(set (bound-vars-lambda (Identity)) (EmptySet))

; Constant function inherits from the constant
(rule () ((set (free-vars-lambda (ConstantFunc ?expr)) (free-vars ?expr))))
(rule () ((set (bound-vars-lambda (ConstantFunc ?expr)) (bound-vars ?expr))))

; ========================================
; VARSET MEMBERSHIP CHECKING
; ========================================

; VarSet membership check - enables independence testing
(set (contains-var (EmptySet) 0) false)
(set (contains-var (EmptySet) 1) false)
(set (contains-var (EmptySet) 2) false)

(set (contains-var (SingleVar 0) 0) true)
(set (contains-var (SingleVar 1) 1) true)
(set (contains-var (SingleVar 2) 2) true)

(set (contains-var (SingleVar 0) 1) false)
(set (contains-var (SingleVar 0) 2) false)
(set (contains-var (SingleVar 1) 0) false)
(set (contains-var (SingleVar 1) 2) false)
(set (contains-var (SingleVar 2) 0) false)
(set (contains-var (SingleVar 2) 1) false)

; Union membership - true if either side contains the variable
(rule ((= true (contains-var ?left ?var)))
      ((set (contains-var (UnionSet ?left ?right) ?var) true)))
(rule ((= true (contains-var ?right ?var)))
      ((set (contains-var (UnionSet ?left ?right) ?var) true)))
(rule ((= false (contains-var ?left ?var))
       (= false (contains-var ?right ?var)))
      ((set (contains-var (UnionSet ?left ?right) ?var) false)))

; ========================================
; INDEPENDENCE CHECKING
; ========================================

; A coefficient is independent of a bound variable if it doesn't contain that variable
(rule ((= ?coeff-deps (free-vars ?coeff))
       (= false (contains-var ?coeff-deps ?bound-var)))
      ((set (is-independent-of ?coeff ?bound-var) true)))

; ========================================
; SAFE OPTIMIZATION RULES
; ========================================

; Create ruleset for dependency-aware optimizations
(ruleset safe_optimizations)

; Safe coefficient factoring - only if coefficient is independent of bound variable
(rule ((= lhs (LambdaFunc ?var (Mul ?coeff ?term)))
       (= true (is-independent-of ?coeff ?var)))
      ((union lhs (FactoredLambda ?coeff (LambdaFunc ?var ?term))))
      :ruleset safe_optimizations)

; Constructor for factored lambda expressions
(constructor FactoredLambda (Math Lambda) Lambda)

; Factored lambda dependency rules
(rule () ((set (free-vars-lambda (FactoredLambda ?coeff ?lambda)) 
               (UnionSet (free-vars ?coeff) (free-vars-lambda ?lambda)))))
(rule () ((set (bound-vars-lambda (FactoredLambda ?coeff ?lambda)) 
               (UnionSet (bound-vars ?coeff) (bound-vars-lambda ?lambda)))))

; ========================================
; EXTENDED VARIABLE PATTERNS
; ========================================

; Generate more variable patterns for better coverage
(rule ((= n 3)) ((set (free-vars (UserVar n)) (SingleVar n))))
(rule ((= n 4)) ((set (free-vars (UserVar n)) (SingleVar n))))
(rule ((= n 5)) ((set (free-vars (UserVar n)) (SingleVar n))))

(rule ((= n 3)) ((set (bound-vars (UserVar n)) (EmptySet))))
(rule ((= n 4)) ((set (bound-vars (UserVar n)) (EmptySet))))
(rule ((= n 5)) ((set (bound-vars (UserVar n)) (EmptySet))))

(rule ((= n 3)) ((set (free-vars (BoundVar n)) (EmptySet))))
(rule ((= n 4)) ((set (free-vars (BoundVar n)) (EmptySet))))
(rule ((= n 5)) ((set (free-vars (BoundVar n)) (EmptySet))))

(rule ((= n 3)) ((set (bound-vars (BoundVar n)) (SingleVar n))))
(rule ((= n 4)) ((set (bound-vars (BoundVar n)) (SingleVar n))))
(rule ((= n 5)) ((set (bound-vars (BoundVar n)) (SingleVar n))))

; Extended membership checking
(set (contains-var (EmptySet) 3) false)
(set (contains-var (EmptySet) 4) false)
(set (contains-var (EmptySet) 5) false)

(set (contains-var (SingleVar 3) 3) true)
(set (contains-var (SingleVar 4) 4) true)
(set (contains-var (SingleVar 5) 5) true)

(set (contains-var (SingleVar 3) 0) false)
(set (contains-var (SingleVar 3) 1) false)
(set (contains-var (SingleVar 3) 2) false)
(set (contains-var (SingleVar 4) 0) false)
(set (contains-var (SingleVar 4) 1) false)
(set (contains-var (SingleVar 4) 2) false)
(set (contains-var (SingleVar 5) 0) false)
(set (contains-var (SingleVar 5) 1) false)
(set (contains-var (SingleVar 5) 2) false)

; ========================================
; DEPENDENCY ANALYSIS RULESET
; ========================================

(ruleset dependency_analysis)

; All dependency computation rules should be in this ruleset
; This allows them to be run in a controlled phase

; ========================================
; USAGE NOTES
; ========================================

; To use this dependency analysis system:
; 1. Include this file after staged_core_math.egg
; 2. Run dependency analysis before optimization phases:
;    (run-schedule 
;      (seq
;        (saturate dependency_analysis)    ; Compute dependencies first
;        (saturate safe_optimizations)     ; Apply safe optimizations
;        (saturate stage1_partitioning)    ; Then regular stages
;        (saturate stage2_constants)
;        (saturate stage3_summation)
;        (saturate stage4_simplify)
;      ))
; 3. Use is-independent-of checks in custom optimization rules 