; ========================================
; SIMPLIFIED DEPENDENCY ANALYSIS FOR DSLCOMPILE
; ========================================
; Essential dependency tracking for safe sum optimization
; Avoids complex boolean merge functions that cause parse errors

; ========================================
; VARIABLE DEPENDENCY TRACKING SYSTEM
; ========================================

; Set of variable indices for dependency tracking
(datatype VarSet
  (EmptySet)                         ; No dependencies
  (SingleVar i64)                    ; Single variable dependency  
  (UnionSet VarSet VarSet)           ; Union of two dependency sets
)

; ========================================
; CORE DEPENDENCY FUNCTIONS  
; ========================================

; Track which variables are used in each expression
(function free-vars (Math) VarSet :merge (UnionSet old new))

; ========================================
; BASIC DEPENDENCY RULES
; ========================================

; Constants have no dependencies
(rule () ((set (free-vars (Num ?n)) (EmptySet))))

; UserVars contribute their index to free variables - use specific patterns for now
(rule () ((set (free-vars (UserVar ?n)) (SingleVar ?n))))

; BoundVars are not free (they're bound by Let constructs)
(rule () ((set (free-vars (BoundVar ?n)) (EmptySet))))


; Binary operations union dependencies from both operands
(rule ((= ?left_deps (free-vars ?a))
       (= ?right_deps (free-vars ?b)))
      ((set (free-vars (Add ?a ?b)) (UnionSet ?left_deps ?right_deps))))
(rule ((= ?left_deps (free-vars ?a))
       (= ?right_deps (free-vars ?b)))
      ((set (free-vars (Mul ?a ?b)) (UnionSet ?left_deps ?right_deps))))
(rule ((= ?left_deps (free-vars ?a))
       (= ?right_deps (free-vars ?b)))
      ((set (free-vars (Div ?a ?b)) (UnionSet ?left_deps ?right_deps))))
(rule ((= ?left_deps (free-vars ?a))
       (= ?right_deps (free-vars ?b)))
      ((set (free-vars (Pow ?a ?b)) (UnionSet ?left_deps ?right_deps))))

; Unary operations inherit dependencies from operand
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Neg ?a)) ?deps)))
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Ln ?a)) ?deps)))
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Exp ?a)) ?deps)))
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Sin ?a)) ?deps)))
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Cos ?a)) ?deps)))
(rule ((= ?deps (free-vars ?a)))
      ((set (free-vars (Sqrt ?a)) ?deps)))

; Let bindings union dependencies from expression and body
(rule ((= ?expr_deps (free-vars ?expr))
       (= ?body_deps (free-vars ?body)))
      ((set (free-vars (Let ?id ?expr ?body)) 
            (UnionSet ?expr_deps ?body_deps))))

; ========================================
; RULESETS FOR PHASED OPTIMIZATION
; ========================================

; Create rulesets for controlled optimization phases
(ruleset dependency_analysis)
(ruleset safe_optimizations)

; Add all dependency computation rules to the dependency_analysis ruleset
; This allows them to be run in a controlled phase before optimizations

; Minimal standalone dependency analysis test
; This file should parse correctly on its own

; Mathematical expressions datatype (minimal)
(datatype Math
  (Num f64)
  (UserVar i64)
  (Add Math Math)
)

; Boolean type
(datatype Bool
  (True)
  (False)
)

; VarSet for dependency tracking
(datatype VarSet
  (EmptySet)
  (SingleVar i64)
  (UnionSet VarSet VarSet)
)

; Boolean merge function - defined FIRST
(function bool-or (Bool Bool) Bool :no-merge)
(set (bool-or (True) (True)) (True))
(set (bool-or (True) (False)) (True))
(set (bool-or (False) (True)) (True))
(set (bool-or (False) (False)) (False))

; Functions that use bool-or - defined AFTER
(function contains-var (VarSet i64) Bool :merge bool-or)
(function free-vars (Math) VarSet :merge (UnionSet old new))

; Basic rules
(set (free-vars (Num 0.0)) (EmptySet))
(set (free-vars (UserVar 0)) (SingleVar 0))
(set (contains-var (EmptySet) 0) (False))
(set (contains-var (SingleVar 0) 0) (True))

; Test rule
(rule () ((set (free-vars (Add ?a ?b)) (UnionSet (free-vars ?a) (free-vars ?b)))))