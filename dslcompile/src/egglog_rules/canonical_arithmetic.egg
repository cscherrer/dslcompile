; Canonical Arithmetic Rules for DSLCompile
; Simplified rules that only handle canonical operations: Add, Mul, Neg, Pow
; This demonstrates the ~40% rule complexity reduction achieved by normalization

; ========================================
; CANONICAL OPERATIONS ONLY
; ========================================
; Note: Sub and Div are not handled here because they are normalized away
; Sub(a, b) → Add(a, Neg(b))
; Div(a, b) → Mul(a, Pow(b, -1))

; ========================================
; COMMUTATIVITY (Simplified)
; ========================================

; Only need commutativity for Add and Mul (not Sub/Div)
(rewrite (Add ?x ?y) (Add ?y ?x))
(rewrite (Mul ?x ?y) (Mul ?y ?x))

; ========================================
; ADDITIVE IDENTITIES (Simplified)
; ========================================

; Addition identity: x + 0 = x
(rewrite (Add ?x (Num 0.0)) ?x)
(rewrite (Add (Num 0.0) ?x) ?x)

; Additive inverse: x + (-x) = 0
(rewrite (Add ?x (Neg ?x)) (Num 0.0))
(rewrite (Add (Neg ?x) ?x) (Num 0.0))

; Addition of same terms: x + x = 2x
(rewrite (Add ?x ?x) (Mul (Num 2.0) ?x))

; ========================================
; MULTIPLICATIVE IDENTITIES (Simplified)
; ========================================

; Multiplication identity: x * 1 = x
(rewrite (Mul ?x (Num 1.0)) ?x)
(rewrite (Mul (Num 1.0) ?x) ?x)

; Multiplication by zero: x * 0 = 0
(rewrite (Mul ?x (Num 0.0)) (Num 0.0))
(rewrite (Mul (Num 0.0) ?x) (Num 0.0))

; Multiplicative inverse: x * x^(-1) = 1 (when x ≠ 0)
; This replaces the need for division rules
(rewrite (Mul ?x (Pow ?x (Num -1.0))) (Num 1.0))

; ========================================
; NEGATION RULES (Canonical)
; ========================================

; Double negation: -(-x) = x
(rewrite (Neg (Neg ?x)) ?x)

; Negation of zero: -0 = 0
(rewrite (Neg (Num 0.0)) (Num 0.0))

; Negation distribution over addition: -(x + y) = (-x) + (-y)
(rewrite (Neg (Add ?x ?y)) (Add (Neg ?x) (Neg ?y)))

; Negation and multiplication: (-x) * y = -(x * y)
(rewrite (Mul (Neg ?x) ?y) (Neg (Mul ?x ?y)))
(rewrite (Mul ?x (Neg ?y)) (Neg (Mul ?x ?y)))

; ========================================
; POWER RULES (Canonical)
; ========================================

; Power identity rules
(rewrite (Pow ?x (Num 1.0)) ?x)         ; x^1 = x
(rewrite (Pow (Num 1.0) ?x) (Num 1.0))  ; 1^x = 1
(rewrite (Pow ?x (Num 0.0)) (Num 1.0))  ; x^0 = 1 (IEEE 754)

; Power addition: x^a * x^b = x^(a+b)
(rewrite (Mul (Pow ?x ?a) (Pow ?x ?b)) (Pow ?x (Add ?a ?b)))

; Power of power: (x^a)^b = x^(a*b)
(rewrite (Pow (Pow ?x ?a) ?b) (Pow ?x (Mul ?a ?b)))

; Power of product: (x*y)^z = x^z * y^z
(rewrite (Pow (Mul ?x ?y) ?z) (Mul (Pow ?x ?z) (Pow ?y ?z)))

; Negative exponent handling (replaces division rules)
(rewrite (Pow ?x (Neg ?a)) (Pow (Pow ?x ?a) (Num -1.0)))

; ========================================
; DISTRIBUTIVE PROPERTIES (Canonical)
; ========================================

; Left distributivity: x * (y + z) = x*y + x*z
(rewrite (Mul ?x (Add ?y ?z)) (Add (Mul ?x ?y) (Mul ?x ?z)))

; Right distributivity: (y + z) * x = y*x + z*x
(rewrite (Mul (Add ?y ?z) ?x) (Add (Mul ?y ?x) (Mul ?z ?x)))

; Factor out common terms: x*y + x*z = x*(y + z)
(rewrite (Add (Mul ?x ?y) (Mul ?x ?z)) (Mul ?x (Add ?y ?z)))

; ========================================
; ALGEBRAIC SIMPLIFICATIONS (Canonical)
; ========================================

; Combine like terms with negation: x + (-y) + y = x
(rewrite (Add (Add ?x (Neg ?y)) ?y) ?x)
(rewrite (Add ?x (Add (Neg ?y) ?y)) ?x)

; Multiplication by reciprocal: x * y^(-1) * y = x
(rewrite (Mul (Mul ?x (Pow ?y (Num -1.0))) ?y) ?x)

; Simplify nested additions: (x + y) + z = x + (y + z)
(rewrite (Add (Add ?x ?y) ?z) (Add ?x (Add ?y ?z)))

; Simplify nested multiplications: (x * y) * z = x * (y * z)
(rewrite (Mul (Mul ?x ?y) ?z) (Mul ?x (Mul ?y ?z)))

; ========================================
; COMPARISON WITH NON-CANONICAL RULES
; ========================================

; BEFORE NORMALIZATION (would need these additional rules):
; - Subtraction commutativity: NOT commutative, so no rule
; - Division commutativity: NOT commutative, so no rule
; - Subtraction identity: x - 0 = x
; - Self-subtraction: x - x = 0
; - Division identity: x / 1 = x
; - Self-division: x / x = 1 (when x ≠ 0)
; - Mixed operations: (x + y) - z, (x * y) / z, etc.
; - Distributivity over subtraction: x * (y - z) = x*y - x*z
; - Distributivity over division: x * (y / z) = (x*y) / z
; - Complex fraction rules: (a/b) / (c/d) = (a*d) / (b*c)
; - Subtraction/division interaction rules
; 
; TOTAL RULES NEEDED WITHOUT NORMALIZATION: ~60-80 rules
; TOTAL RULES NEEDED WITH NORMALIZATION: ~35-45 rules
; REDUCTION: ~40% fewer rules to maintain and debug

; ========================================
; BENEFITS DEMONSTRATED
; ========================================

; 1. CONSISTENCY: All operations follow additive/multiplicative patterns
; 2. COMPLETENESS: No missing cases for Sub/Div interactions
; 3. MAINTAINABILITY: Fewer rules to debug and verify
; 4. OPTIMIZATION: More opportunities for algebraic manipulation
; 5. EXTENSIBILITY: New operations only need canonical form rules 