; Minimal Constant Propagation Rules for DSLCompile
; Start with absolute basics that work perfectly

; ========================================
; BASIC DATATYPE DEFINITION  
; ========================================

(datatype Math
  (Num f64)
  (Var String)
  (Add Math Math)
  (Mul Math Math)
)

; ========================================
; VARIABLE DEPENDENCY ANALYSIS
; ========================================

; Relations to track what variables an expression depends on
(relation depends-on (Math String))
(relation is-const (Math))
(relation var-free (Math))

; Base cases: constants don't depend on any variables
(rule ((= e (Num n)))
      ((is-const e)
       (var-free e)))

; Variables depend only on themselves
(rule ((= e (Var v)))
      ((depends-on e v)))

; Dependency propagation for operations
(rule ((= e (Add a b)) (depends-on a v))
      ((depends-on e v)))

(rule ((= e (Add a b)) (depends-on b v))
      ((depends-on e v)))

(rule ((= e (Mul a b)) (depends-on a v))
      ((depends-on e v)))

(rule ((= e (Mul a b)) (depends-on b v))
      ((depends-on e v)))

; An expression is var-free if it doesn't depend on any variable we care about
(rule ((= e (Add a b)) (var-free a) (var-free b))
      ((var-free e)))

(rule ((= e (Mul a b)) (var-free a) (var-free b))
      ((var-free e)))

; ========================================
; BASIC CONSTANT FOLDING RULES (UNIDIRECTIONAL)
; ========================================

; Addition constant folding
(rule ((= lhs (Add (Num a) (Num b))))
      ((union lhs (Num (+ a b)))))

; Multiplication constant folding
(rule ((= lhs (Mul (Num a) (Num b))))
      ((union lhs (Num (* a b)))))

; ========================================
; BASIC IDENTITY RULES (UNIDIRECTIONAL - always better)
; ========================================

; Addition identities
(rule ((= lhs (Add ?x (Num 0.0))))
      ((union lhs ?x)))

(rule ((= lhs (Add (Num 0.0) ?x)))
      ((union lhs ?x)))

; Multiplication identities
(rule ((= lhs (Mul ?x (Num 1.0))))
      ((union lhs ?x)))

(rule ((= lhs (Mul (Num 1.0) ?x)))
      ((union lhs ?x)))

; Zero elimination (UNIDIRECTIONAL - always better)
(rule ((= lhs (Mul ?x (Num 0.0))))
      ((union lhs (Num 0.0))))

(rule ((= lhs (Mul (Num 0.0) ?x)))
      ((union lhs (Num 0.0))))

; ========================================
; COMMUTATIVITY AND ASSOCIATIVITY (BI-DIRECTIONAL)
; ========================================

(rewrite (Add ?x ?y) (Add ?y ?x))
(rewrite (Mul ?x ?y) (Mul ?y ?x))

; Associativity - CAREFUL: Only add this for focused tests
; (rewrite (Add (Add ?x ?y) ?z) (Add ?x (Add ?y ?z)))
; (rewrite (Add ?x (Add ?y ?z)) (Add (Add ?x ?y) ?z))

; ========================================
; VARIABLE PARTITIONING RULES
; ========================================

; Collect constants in addition: (a + b) + c where a,b are constants
(rule ((= lhs (Add (Add (Num a) (Num b)) ?rest)))
      ((union lhs (Add (Num (+ a b)) ?rest))))

; Move constants to the front for canonical form
; Note: We'll handle this differently - just focus on collecting like terms first

; Collect like variables: x + x = 2*x (simplified case)
(rule ((= lhs (Add (Var v) (Var v))))
      ((union lhs (Mul (Num 2.0) (Var v)))))

; More complex: 2*x + 3*x = 5*x  
(rule ((= lhs (Add (Mul (Num a) (Var v)) (Mul (Num b) (Var v)))))
      ((union lhs (Mul (Num (+ a b)) (Var v)))))

; Handle x + 2*x = 3*x
(rule ((= lhs (Add (Var v) (Mul (Num a) (Var v)))))
      ((union lhs (Mul (Num (+ 1.0 a)) (Var v)))))

(rule ((= lhs (Add (Mul (Num a) (Var v)) (Var v))))
      ((union lhs (Mul (Num (+ a 1.0)) (Var v))))) 