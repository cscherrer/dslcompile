; Final Comprehensive Test - Production Readiness Check
; Test all key features that DSLCompile Rust integration will need

(include "summation_with_collections.egg")

; ========================================
; CORE COLLECTION OPERATIONS
; ========================================

; Test 1: Empty collection
(let test_empty (Sum (Empty)))  ; → 0.0

; Test 2: Singleton 
(let test_singleton (Sum (Singleton (Num 42.0))))  ; → 42.0

; ========================================
; PRIORITY OPTIMIZATIONS (User's Key Requirements)
; ========================================

; Test 3: Sum splitting - Σ(f + g) = Σ(f) + Σ(g)
(let test_splitting 
     (Sum (Map (LambdaFunc 0 (Add (Var 0) (Num 5.0))) 
               (Range (Num 1.0) (Num 3.0)))))  ; → Σ(x) + Σ(5) = 6 + 15 = 21

; Test 4: Constant factor - Σ(k * f) = k * Σ(f)  
(let test_factor 
     (Sum (Map (LambdaFunc 0 (Mul (Num 7.0) (Var 0))) 
               (Range (Num 1.0) (Num 3.0)))))  ; → 7 * Σ(x) = 7 * 6 = 42

; ========================================
; CONSTANT EVALUATION
; ========================================

; Test 5: Direct range evaluation
(let test_range_direct (Sum (Range (Num 1.0) (Num 4.0))))  ; → 10.0

; Test 6: Constant map evaluation  
(let test_constant_map 
     (Sum (Map (ConstantFunc (Num 8.0)) (Range (Num 1.0) (Num 3.0)))))  ; → 8*3 = 24

; Test 7: Combined constant evaluation
(let test_combined (Mul (Num 3.0) (Sum (Range (Num 1.0) (Num 5.0)))))  ; → 3*15 = 45

; ========================================
; LAMBDA CALCULUS & BETA REDUCTION
; ========================================

; Test 8: Identity lambda
(let test_identity (LambdaFunc 0 (Var 0)))  ; → Identity

; Test 9: Constant lambda
(let test_const_lambda (LambdaFunc 0 (Num 99.0)))  ; → ConstantFunc(99.0)

; Test 10: Variable substitution (different variable)
(let test_var_sub (LambdaFunc 0 (Var 1)))  ; → ConstantFunc(Var(1))

; ========================================
; COMPLEX REALISTIC CASES
; ========================================

; Test 11: Complex sum that should fully optimize
; Σ(3*x + 2 for x in 1..2) = 3*Σ(x) + 2*n = 3*3 + 2*2 = 9+4 = 13
(let test_complex 
     (Sum (Map (LambdaFunc 0 (Add (Mul (Num 3.0) (Var 0)) (Num 2.0))) 
               (Range (Num 1.0) (Num 2.0)))))

; Test 12: Nested identity optimization
(let test_nested_identity 
     (Sum (Map (Identity) (Range (Num 1.0) (Num 10.0)))))  ; → 55

; ========================================
; VARIABLE PARTITIONING (From Earlier Success)
; ========================================

; Test 13: Basic variable collection (integer indices)
(let test_var_collect (Add (Var 0) (Var 0)))  ; → 2*Var(0)

; Test 14: Coefficient collection
(let test_coeff_collect 
     (Add (Mul (Num 4.0) (Var 1)) (Mul (Num 6.0) (Var 1))))  ; → 10*Var(1)

; ========================================
; RUN OPTIMIZATION AND EXTRACT ALL RESULTS
; ========================================

(run-schedule (repeat 30 (saturate (run))))

; Extract all test results
(query-extract test_empty)
(query-extract test_singleton) 
(query-extract test_splitting)
(query-extract test_factor)
(query-extract test_range_direct)
(query-extract test_constant_map)
(query-extract test_combined)
(query-extract test_identity)
(query-extract test_const_lambda)
(query-extract test_var_sub)
(query-extract test_complex)
(query-extract test_nested_identity)
(query-extract test_var_collect)
(query-extract test_coeff_collect) 