; ========================================
; SIMPLE DEPENDENCY ANALYSIS USING EGGLOG'S BUILT-IN SETS
; ========================================
; This is a minimal, conservative implementation that avoids complex patterns
; that could cause infinite loops or exponential growth.

; ========================================
; SET SORT DECLARATION
; ========================================
; Declare the Set sort for i64 elements (variable IDs)
(sort VarSetBase (Set i64))

; ========================================
; DEPENDENCY TRACKING FUNCTION - USING BUILT-IN SETS
; ========================================
; Track which variables (by integer ID) each expression depends on
(function free-vars (Math) VarSetBase :merge (set-union old new))

; ========================================
; BASE CASES - DIRECT COMPUTATION
; ========================================
(rule ((Num ?c))
      ((set (free-vars (Num ?c)) (set-empty))))

(rule ((UserVar ?v))
      ((set (free-vars (UserVar ?v)) (set-of ?v))))

(rule ((BoundVar ?id))
      ((set (free-vars (BoundVar ?id)) (set-empty))))

; ========================================
; COMPOSITE EXPRESSIONS - USING BUILT-IN SET OPERATIONS
; ========================================
; Following the pattern from interval.egg: bind expression, guard on operands, then compute

; Binary operations - union the dependencies
(rule ((= add_expr (Add ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars add_expr) (set-union dep_a dep_b))))

(rule ((= mul_expr (Mul ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars mul_expr) (set-union dep_a dep_b))))

(rule ((= sub_expr (Sub ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars sub_expr) (set-union dep_a dep_b))))

(rule ((= div_expr (Div ?a ?b))
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars div_expr) (set-union dep_a dep_b))))

(rule ((= pow_expr (Pow ?a ?b))  
       (= dep_a (free-vars ?a))
       (= dep_b (free-vars ?b)))
      ((set (free-vars pow_expr) (set-union dep_a dep_b))))

; Unary operations - pass through dependencies
(rule ((= neg_expr (Neg ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars neg_expr) dep_a)))

(rule ((= ln_expr (Ln ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars ln_expr) dep_a)))

(rule ((= exp_expr (Exp ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars exp_expr) dep_a)))

(rule ((= sin_expr (Sin ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars sin_expr) dep_a)))

(rule ((= cos_expr (Cos ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars cos_expr) dep_a)))

(rule ((= sqrt_expr (Sqrt ?a))
       (= dep_a (free-vars ?a)))
      ((set (free-vars sqrt_expr) dep_a)))

; Let expressions - union dependencies from expression and body
; Note: This is a simplified version - proper scoping would need more sophisticated handling
(rule ((= let_expr (Let ?id ?expr ?body))
       (= dep_expr (free-vars ?expr))
       (= dep_body (free-vars ?body)))
      ((set (free-vars let_expr) (set-union dep_expr dep_body))))

; ========================================
; COLLECTION DEPENDENCY ANALYSIS 
; ========================================
; Track dependencies through collections for proper sum optimization

; Collection dependency tracking function
(function collection-deps (Collection) VarSetBase :merge (set-union old new))

; Base collection cases
(rule ((Empty))
      ((set (collection-deps (Empty)) (set-empty))))

(rule ((DataArray ?id))
      ((set (collection-deps (DataArray ?id)) (set-empty)))) ; DataArrays have no variable dependencies

; Collections that depend on expressions
(rule ((= singleton_coll (Singleton ?expr))
       (= expr_deps (free-vars ?expr)))
      ((set (collection-deps singleton_coll) expr_deps)))

(rule ((= range_coll (Range ?start ?end))
       (= start_deps (free-vars ?start))
       (= end_deps (free-vars ?end)))
      ((set (collection-deps range_coll) (set-union start_deps end_deps))))

; ========================================
; SUM DEPENDENCY ANALYSIS - PROPER IMPLEMENTATION
; ========================================
; For sum optimization, we need to track dependencies through collections

(rule ((= sum_expr (Sum ?collection))
       (= coll_deps (collection-deps ?collection)))
      ((set (free-vars sum_expr) coll_deps)))

; ========================================
; LAMBDA DEPENDENCY ANALYSIS
; ========================================
; Track dependencies through lambda expressions for mapped collections

; Lambda dependency tracking function  
(function lambda-deps (Lambda) VarSetBase :merge (set-union old new))

; Base lambda cases
(rule ((Identity))
      ((set (lambda-deps (Identity)) (set-empty))))

; Lambdas that depend on expressions
(rule ((= const_lambda (ConstantFunc ?expr))
       (= expr_deps (free-vars ?expr)))
      ((set (lambda-deps const_lambda) expr_deps)))

(rule ((= lambda_func (LambdaFunc ?var ?expr))
       (= expr_deps (free-vars ?expr)))
      ((set (lambda-deps lambda_func) expr_deps))) ; Note: This is simplified - doesn't handle bound variable scoping yet

; ========================================
; MAP COLLECTION DEPENDENCY ANALYSIS
; ========================================  
; Handle Map operations that combine lambdas and collections

(rule ((= mapped_coll (Map ?lambda ?collection))
       (= lambda_deps_val (lambda-deps ?lambda))
       (= coll_deps_val (collection-deps ?collection)))
      ((set (collection-deps mapped_coll) (set-union lambda_deps_val coll_deps_val))))