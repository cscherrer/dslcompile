//! Arena-based allocation for AST nodes
//!
//! This module provides memory-efficient arena allocation for AST expressions,
//! eliminating the heavy Box allocation overhead while maintaining the same API.
//!
//! Benefits:
//! - Reduced memory allocations (single arena vs many Box allocations)
//! - Better cache locality for tree traversal
//! - Reduced memory fragmentation
//! - Preserved API compatibility through smart design

use crate::ast::{Scalar, multiplicity::Multiplicity};
use std::{
    collections::BTreeMap,
    fmt::{Debug, Display},
    marker::PhantomData,
};

/// Identifier for expressions in the arena
///
/// This is a lightweight reference that replaces Box<`ASTRepr`<T>>
/// in the arena-based system.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ExprId(usize);

impl ExprId {
    /// Create a new expression ID (internal use only)
    pub(crate) fn new(id: usize) -> Self {
        Self(id)
    }

    /// Get the internal ID (for debugging)
    #[must_use]
    pub fn id(&self) -> usize {
        self.0
    }
}

impl Display for ExprId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "#{}", self.0)
    }
}

/// Arena-based AST representation that eliminates Box allocations
///
/// This is the arena version of `ASTRepr` that uses `ExprId` references
/// instead of Box<`ASTRepr`<T>>.
#[derive(Debug, Clone, PartialEq)]
pub enum ArenaAST<T: Scalar> {
    /// Constants: 42.0, Ï€, etc.
    Constant(T),
    /// Variables: x, y, z (referenced by index for performance)
    Variable(usize),
    /// CSE-bound variables (generated by Common Subexpression Elimination)
    BoundVar(usize),
    /// Let bindings for Common Subexpression Elimination
    /// `Let(binding_id, expression, body)` - uses `ExprId` instead of Box
    Let(usize, ExprId, ExprId),
    /// Multiset operations using arena-based `MultiSet`
    Add(ArenaMultiSet<T>), // Addition of multiple terms: a + b + c
    Mul(ArenaMultiSet<T>), // Multiplication of multiple factors: a * b * c
    /// Binary operations using `ExprId` instead of Box
    Sub(ExprId, ExprId),
    Div(ExprId, ExprId),
    Pow(ExprId, ExprId),
    /// Unary operations using `ExprId` instead of Box
    Neg(ExprId),
    Ln(ExprId),
    Exp(ExprId),
    Sin(ExprId),
    Cos(ExprId),
    Sqrt(ExprId),
    /// Compositional summation using arena-based collection
    Sum(ArenaCollection<T>),
    /// Lambda expressions using arena-based lambda
    Lambda(ArenaLambda<T>),
}

/// Arena-based multiset that uses `ExprId` instead of storing expressions directly
#[derive(Clone, PartialEq, Eq)]
pub struct ArenaMultiSet<T> {
    map: BTreeMap<ExprId, Multiplicity>,
    _phantom: PhantomData<T>,
}

impl<T> ArenaMultiSet<T> {
    /// Create a new empty arena multiset
    #[must_use]
    pub fn new() -> Self {
        Self {
            map: BTreeMap::new(),
            _phantom: PhantomData,
        }
    }

    /// Create an arena multiset from a single expression ID
    #[must_use]
    pub fn singleton(expr_id: ExprId) -> Self {
        let mut map = BTreeMap::new();
        map.insert(expr_id, Multiplicity::one());
        Self {
            map,
            _phantom: PhantomData,
        }
    }

    /// Create an arena multiset from two expression IDs
    #[must_use]
    pub fn pair(a: ExprId, b: ExprId) -> Self {
        let mut multiset = Self::new();
        multiset.insert(a);
        multiset.insert(b);
        multiset
    }

    /// Insert an expression ID into the multiset
    pub fn insert(&mut self, expr_id: ExprId) {
        *self.map.entry(expr_id).or_insert_with(Multiplicity::zero) += Multiplicity::one();
    }

    /// Get the multiplicity of an expression ID
    pub fn multiplicity(&self, expr_id: &ExprId) -> Multiplicity {
        self.map
            .get(expr_id)
            .cloned()
            .unwrap_or_else(Multiplicity::zero)
    }

    /// Iterate over (`ExprId`, Multiplicity) pairs
    pub fn iter(&self) -> impl Iterator<Item = (&ExprId, &Multiplicity)> {
        self.map.iter()
    }

    /// Check if the multiset is empty
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.map.is_empty()
    }

    /// Get the number of unique elements
    #[must_use]
    pub fn len(&self) -> usize {
        self.map.len()
    }
}

impl<T> Debug for ArenaMultiSet<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_map().entries(self.map.iter()).finish()
    }
}

impl<T> Default for ArenaMultiSet<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Arena-based collection that uses `ExprId` references
#[derive(Debug, Clone, PartialEq)]
pub enum ArenaCollection<T: Scalar> {
    /// Empty collection
    Empty,
    /// Single element collection
    Singleton(ExprId),
    /// Mathematical range [start, end] (inclusive)
    Range { start: ExprId, end: ExprId },
    /// Variable reference for data collections
    Variable(usize),
    /// Filtered collection with predicate
    Filter {
        collection: Box<ArenaCollection<T>>,
        predicate: ExprId,
    },
    /// Map function over collection (Iterator pattern)
    Map {
        lambda: ArenaLambda<T>,
        collection: Box<ArenaCollection<T>>,
    },
    /// Constant iterable collection (vectors, arrays, etc.)
    Constant(Vec<T>),
}

/// Arena-based lambda expressions
#[derive(Debug, Clone, PartialEq)]
pub struct ArenaLambda<T: Scalar> {
    /// Variable indices that this lambda binds
    pub var_indices: Vec<usize>,
    /// The lambda body expression (`ExprId` instead of Box)
    pub body: ExprId,
    _phantom: PhantomData<T>,
}

impl<T: Scalar> ArenaLambda<T> {
    /// Create a new arena lambda
    #[must_use]
    pub fn new(var_indices: Vec<usize>, body: ExprId) -> Self {
        Self {
            var_indices,
            body,
            _phantom: PhantomData,
        }
    }
}

/// Expression arena that manages all AST nodes
///
/// This provides memory-efficient storage for expressions and eliminates
/// the Box allocation overhead of the traditional `ASTRepr` design.
#[derive(Debug)]
pub struct ExprArena<T: Scalar> {
    /// Storage for all expressions
    nodes: Vec<ArenaAST<T>>,
    /// Next available ID
    next_id: usize,
}

impl<T: Scalar> ExprArena<T> {
    /// Create a new expression arena
    #[must_use]
    pub fn new() -> Self {
        Self {
            nodes: Vec::new(),
            next_id: 0,
        }
    }

    /// Create a new expression arena with initial capacity
    #[must_use]
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            nodes: Vec::with_capacity(capacity),
            next_id: 0,
        }
    }

    /// Allocate a new expression in the arena and return its ID
    pub fn alloc(&mut self, expr: ArenaAST<T>) -> ExprId {
        let id = ExprId::new(self.next_id);
        self.nodes.push(expr);
        self.next_id += 1;
        id
    }

    /// Get an expression by ID
    #[must_use]
    pub fn get(&self, id: ExprId) -> Option<&ArenaAST<T>> {
        self.nodes.get(id.0)
    }

    /// Get a mutable reference to an expression by ID
    pub fn get_mut(&mut self, id: ExprId) -> Option<&mut ArenaAST<T>> {
        self.nodes.get_mut(id.0)
    }

    /// Get the number of expressions in the arena
    #[must_use]
    pub fn len(&self) -> usize {
        self.nodes.len()
    }

    /// Check if the arena is empty
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.nodes.is_empty()
    }

    /// Create a constant expression
    pub fn constant(&mut self, value: T) -> ExprId {
        self.alloc(ArenaAST::Constant(value))
    }

    /// Create a variable expression
    pub fn variable(&mut self, index: usize) -> ExprId {
        self.alloc(ArenaAST::Variable(index))
    }

    /// Create a bound variable expression  
    pub fn bound_var(&mut self, index: usize) -> ExprId {
        self.alloc(ArenaAST::BoundVar(index))
    }

    /// Create an addition expression from multiple terms
    pub fn add(&mut self, terms: impl IntoIterator<Item = ExprId>) -> ExprId {
        let mut multiset = ArenaMultiSet::new();
        for term in terms {
            multiset.insert(term);
        }
        self.alloc(ArenaAST::Add(multiset))
    }

    /// Create a binary addition expression (convenience)
    pub fn add_binary(&mut self, left: ExprId, right: ExprId) -> ExprId {
        self.add([left, right])
    }

    /// Create a multiplication expression from multiple factors
    pub fn mul(&mut self, factors: impl IntoIterator<Item = ExprId>) -> ExprId {
        let mut multiset = ArenaMultiSet::new();
        for factor in factors {
            multiset.insert(factor);
        }
        self.alloc(ArenaAST::Mul(multiset))
    }

    /// Create a binary multiplication expression (convenience)
    pub fn mul_binary(&mut self, left: ExprId, right: ExprId) -> ExprId {
        self.mul([left, right])
    }

    /// Create a subtraction expression
    pub fn sub(&mut self, left: ExprId, right: ExprId) -> ExprId {
        self.alloc(ArenaAST::Sub(left, right))
    }

    /// Create a division expression
    pub fn div(&mut self, left: ExprId, right: ExprId) -> ExprId {
        self.alloc(ArenaAST::Div(left, right))
    }

    /// Create a power expression
    pub fn pow(&mut self, base: ExprId, exponent: ExprId) -> ExprId {
        self.alloc(ArenaAST::Pow(base, exponent))
    }

    /// Create a negation expression
    pub fn neg(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Neg(operand))
    }

    /// Create a natural logarithm expression
    pub fn ln(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Ln(operand))
    }

    /// Create an exponential expression
    pub fn exp(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Exp(operand))
    }

    /// Create a sine expression
    pub fn sin(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Sin(operand))
    }

    /// Create a cosine expression
    pub fn cos(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Cos(operand))
    }

    /// Create a square root expression
    pub fn sqrt(&mut self, operand: ExprId) -> ExprId {
        self.alloc(ArenaAST::Sqrt(operand))
    }

    /// Create a let binding expression
    pub fn let_binding(&mut self, binding_id: usize, expr: ExprId, body: ExprId) -> ExprId {
        self.alloc(ArenaAST::Let(binding_id, expr, body))
    }

    /// Create a sum expression
    pub fn sum(&mut self, collection: ArenaCollection<T>) -> ExprId {
        self.alloc(ArenaAST::Sum(collection))
    }

    /// Create a lambda expression
    pub fn lambda(&mut self, var_indices: Vec<usize>, body: ExprId) -> ExprId {
        self.alloc(ArenaAST::Lambda(ArenaLambda::new(var_indices, body)))
    }
}

impl<T: Scalar> Default for ExprArena<T> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_arena_basic_operations() {
        let mut arena = ExprArena::<f64>::new();

        // Create some basic expressions
        let x = arena.variable(0);
        let y = arena.variable(1);
        let two = arena.constant(2.0);

        // x + y
        let sum = arena.add_binary(x, y);

        // 2 * (x + y)
        let product = arena.mul_binary(two, sum);

        // Verify the structure
        assert_eq!(arena.len(), 5); // x, y, 2.0, sum, product

        match arena.get(sum).unwrap() {
            ArenaAST::Add(multiset) => {
                assert_eq!(multiset.len(), 2);
                assert!(multiset.iter().any(|(id, _)| *id == x));
                assert!(multiset.iter().any(|(id, _)| *id == y));
            }
            _ => panic!("Expected Add node"),
        }

        match arena.get(product).unwrap() {
            ArenaAST::Mul(multiset) => {
                assert_eq!(multiset.len(), 2);
                assert!(multiset.iter().any(|(id, _)| *id == two));
                assert!(multiset.iter().any(|(id, _)| *id == sum));
            }
            _ => panic!("Expected Mul node"),
        }
    }

    #[test]
    fn test_arena_memory_efficiency() {
        let mut arena = ExprArena::<f64>::new();

        // Create a shared subexpression: x + 1
        let x = arena.variable(0);
        let one = arena.constant(1.0);
        let x_plus_one = arena.add_binary(x, one);

        // Use it in two different contexts: (x + 1) * 2 and (x + 1) * 3
        let two = arena.constant(2.0);
        let three = arena.constant(3.0);
        let expr1 = arena.mul_binary(x_plus_one, two);
        let expr2 = arena.mul_binary(x_plus_one, three);

        // The shared subexpression (x + 1) should only be stored once
        assert_eq!(arena.len(), 7); // x, 1, x+1, 2, 3, expr1, expr2

        // Both expressions should reference the same x_plus_one node
        match (arena.get(expr1).unwrap(), arena.get(expr2).unwrap()) {
            (ArenaAST::Mul(m1), ArenaAST::Mul(m2)) => {
                assert!(m1.iter().any(|(id, _)| *id == x_plus_one));
                assert!(m2.iter().any(|(id, _)| *id == x_plus_one));
            }
            _ => panic!("Expected Mul nodes"),
        }
    }
}
