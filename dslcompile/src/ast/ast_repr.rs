//! AST Representation for Mathematical Expressions
//!
//! This module defines the `ASTRepr` enum which represents mathematical expressions
//! as an abstract syntax tree. This representation is used for JIT compilation,
//! symbolic optimization, and other analysis tasks.

use crate::ast::{ExpressionType, Scalar, multiset::MultiSet};
use num_traits::{Float, FromPrimitive, One, Zero};

/// Collection types for compositional summation operations
#[derive(Debug, Clone, PartialEq)]
pub enum Collection<T: ExpressionType + PartialOrd> {
    /// Empty collection
    Empty,
    /// Single element collection
    Singleton(Box<ASTRepr<T>>),
    /// Mathematical range [start, end] (inclusive)
    Range {
        start: Box<ASTRepr<T>>,
        end: Box<ASTRepr<T>>,
    },

    /// Variable reference for data collections
    ///
    /// Uses the same unified Variable(n) indexing as `ASTRepr::Variable`.
    /// At evaluation time, the system determines whether Variable(n) contains
    /// scalar data or collection data based on the actual stored type.
    ///
    /// Example unified indexing:
    /// ```text
    /// Variable(0) = scalar parameter mu
    /// Variable(1) = scalar parameter sigma
    /// Variable(2) = data array [1.0, 2.0, 3.0]
    /// ```
    ///
    /// In expressions: Variable(0) + Variable(1) (arithmetic)
    /// In collections: Sum(Variable(2)) (iteration over data)
    Variable(usize),
    /// Filtered collection with predicate
    Filter {
        collection: Box<Collection<T>>,
        predicate: Box<ASTRepr<T>>,
    },
    /// Map function over collection (Iterator pattern)
    Map {
        lambda: Box<Lambda<T>>,
        collection: Box<Collection<T>>,
    },
    /// Direct data array embedding for efficient summation
    /// This embeds the data directly in the AST, avoiding variable indexing issues
    DataArray(Vec<T>),
}

/// Lambda expressions for mapping functions
#[derive(Debug, Clone, PartialEq)]
pub struct Lambda<T: ExpressionType + PartialOrd> {
    /// Variable indices that this lambda binds
    /// - Empty vec: constant function (ignores input)
    /// - Single element: single-argument lambda
    /// - Multiple elements: multi-argument lambda
    pub var_indices: Vec<usize>,
    /// The lambda body expression
    pub body: Box<ASTRepr<T>>,
}

/// JIT compilation representation for mathematical expressions
///
/// This enum represents mathematical expressions in a form suitable for JIT compilation
/// using Cranelift. Each variant corresponds to a mathematical operation that can be
/// compiled to native machine code.
///
/// # Implementation Note
///
/// This AST representation is an internal implementation detail. External users should
/// use `DynamicContext` to build expressions instead of constructing AST nodes directly.
///
/// Variables are referenced by index for optimal performance, using vector indexing
/// instead of string lookups. Variable indices are managed automatically by `DynamicContext`.
///
/// # ⚠️ Important: Use `DynamicContext` Instead
///
/// **Don't do this (manual AST construction):**
/// ```rust,ignore
/// // ❌ Manual AST construction - error-prone and verbose
/// use dslcompile::ast::ASTRepr;
/// let x = ASTRepr::Variable(0);  // Manual index management
/// let y = ASTRepr::Variable(1);  // Risk of index collisions
/// let expr = x + y;
/// ```
///
/// **Do this instead (proper `DynamicContext` API):**
/// ```rust
/// // ✅ Proper expression building - automatic and safe
/// use dslcompile::prelude::*;
/// let mut ctx = DynamicContext::new();
/// let x: DynamicExpr<f64> = ctx.var();  // Automatic index management
/// let y: DynamicExpr<f64> = ctx.var();  // No collision risk
/// let expr = &x + &y; // Natural syntax
/// ```
#[derive(Debug, Clone, PartialEq)]
pub enum ASTRepr<T: ExpressionType + PartialOrd> {
    /// Constants: 42.0, π, etc.
    Constant(T),
    /// Variables: x, y, z (referenced by index for performance)
    /// Maps to (`UserVar` i64) in egglog
    Variable(usize),
    /// CSE-bound variables (generated by Common Subexpression Elimination)
    /// Maps to (`BoundVar` i64) in egglog
    BoundVar(usize),
    /// Let bindings for Common Subexpression Elimination
    /// `Let(binding_id`, expression, body) maps to (Let i64 Math Math) in egglog
    Let(usize, Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    /// Multiset operations (n-ary, naturally associative/commutative)
    Add(MultiSet<ASTRepr<T>>), // Addition of multiple terms: a + b + c
    Mul(MultiSet<ASTRepr<T>>), // Multiplication of multiple factors: a * b * c
    /// Binary operations (non-associative/commutative)
    Sub(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Div(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Pow(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    /// Unary operations
    Neg(Box<ASTRepr<T>>),
    Ln(Box<ASTRepr<T>>),
    Exp(Box<ASTRepr<T>>),
    Sin(Box<ASTRepr<T>>),
    Cos(Box<ASTRepr<T>>),
    Sqrt(Box<ASTRepr<T>>),
    /// Compositional summation using iterator abstraction
    ///
    /// Creates expressions like:
    /// - Simple: `Sum(Range(1, n))` → sum over range with identity
    /// - Mapped: `Sum(Map(f, Range(1, n)))` → sum f(i) for i in 1..n
    /// - Data: `Sum(DataArray(0))` → sum over data array
    /// - Complex: `Sum(Map(f, Union(A, B)))` → sum f(x) for x in A∪B
    Sum(Box<Collection<T>>),
    /// Lambda expressions for higher-order functions
    /// Used in currying transformations and function composition
    Lambda(Box<Lambda<T>>),
}

impl<T: ExpressionType + PartialOrd> ASTRepr<T> {
    /// Create a binary addition (convenience for migration)
    pub fn add_binary(left: ASTRepr<T>, right: ASTRepr<T>) -> ASTRepr<T> {
        ASTRepr::Add(MultiSet::pair(left, right))
    }

    /// Create a binary multiplication (convenience for migration)  
    pub fn mul_binary(left: ASTRepr<T>, right: ASTRepr<T>) -> ASTRepr<T> {
        ASTRepr::Mul(MultiSet::pair(left, right))
    }

    /// Create a multiset addition from a vector of terms
    #[must_use]
    pub fn add_multiset(terms: Vec<ASTRepr<T>>) -> ASTRepr<T>
    where
        T: Zero,
    {
        if terms.is_empty() {
            ASTRepr::Constant(T::zero())
        } else if terms.len() == 1 {
            terms.into_iter().next().unwrap()
        } else {
            ASTRepr::Add(MultiSet::from_iter(terms))
        }
    }

    /// Create a multiset multiplication from a vector of factors
    #[must_use]
    pub fn mul_multiset(factors: Vec<ASTRepr<T>>) -> ASTRepr<T>
    where
        T: One,
    {
        if factors.is_empty() {
            ASTRepr::Constant(T::one())
        } else if factors.len() == 1 {
            factors.into_iter().next().unwrap()
        } else {
            ASTRepr::Mul(MultiSet::from_iter(factors))
        }
    }

    /// Convenience constructor for Add from slice/array
    pub fn add_from_slice(terms: &[ASTRepr<T>]) -> ASTRepr<T>
    where
        T: Zero,
    {
        Self::add_multiset(terms.to_vec())
    }

    /// Convenience constructor for Mul from slice/array  
    pub fn mul_from_slice(factors: &[ASTRepr<T>]) -> ASTRepr<T>
    where
        T: One,
    {
        Self::mul_multiset(factors.to_vec())
    }

    /// Convenience constructor for Add from array
    pub fn add_from_array<const N: usize>(terms: [ASTRepr<T>; N]) -> ASTRepr<T>
    where
        T: Zero,
    {
        Self::add_multiset(terms.into())
    }

    /// Convenience constructor for Mul from array
    pub fn mul_from_array<const N: usize>(factors: [ASTRepr<T>; N]) -> ASTRepr<T>
    where
        T: One,
    {
        Self::mul_multiset(factors.into())
    }


    /// Get the variable index if this is a variable, otherwise None
    pub fn variable_index(&self) -> Option<usize> {
        match self {
            ASTRepr::Variable(index) | ASTRepr::BoundVar(index) => Some(*index),
            _ => None,
        }
    }


    /// Get a numeric ordering for variants (for `PartialOrd` implementation)
    fn variant_order(&self) -> u8 {
        match self {
            ASTRepr::Constant(_) => 0,
            ASTRepr::Variable(_) => 1,
            ASTRepr::BoundVar(_) => 2,
            ASTRepr::Let(_, _, _) => 3,
            ASTRepr::Add(_) => 4,
            ASTRepr::Mul(_) => 5,
            ASTRepr::Sub(_, _) => 6,
            ASTRepr::Div(_, _) => 7,
            ASTRepr::Pow(_, _) => 8,
            ASTRepr::Neg(_) => 9,
            ASTRepr::Ln(_) => 10,
            ASTRepr::Exp(_) => 11,
            ASTRepr::Sin(_) => 12,
            ASTRepr::Cos(_) => 13,
            ASTRepr::Sqrt(_) => 14,
            ASTRepr::Sum(_) => 15,
            ASTRepr::Lambda(_) => 16,
        }
    }
}

impl<T: ExpressionType + PartialOrd> Collection<T> {


    /// Get a numeric ordering for variants (for `PartialOrd` implementation)
    fn variant_order(&self) -> u8 {
        match self {
            Collection::Empty => 0,
            Collection::Singleton(_) => 1,
            Collection::Range { .. } => 2,
            Collection::Variable(_) => 3,
            Collection::Filter { .. } => 4,
            Collection::Map { .. } => 5,
            Collection::DataArray(_) => 6,
        }
    }
}


impl<T: ExpressionType + PartialOrd> Lambda<T> {
    /// Create a lambda with any number of arguments: λ(vars).body
    /// This is the unified constructor that handles all lambda patterns
    #[must_use]
    pub fn new(var_indices: Vec<usize>, body: Box<ASTRepr<T>>) -> Self {
        Lambda { var_indices, body }
    }

    /// Create a single-argument lambda: λx.body (convenience method)
    #[must_use]
    pub fn single(var_index: usize, body: Box<ASTRepr<T>>) -> Self {
        Self::new(vec![var_index], body)
    }

    /// Create identity lambda: λx.x
    #[must_use]
    pub fn identity() -> Self {
        Self::new(vec![0], Box::new(ASTRepr::Variable(0)))
    }

    /// Create constant lambda: λ_.c (ignores all inputs)
    pub fn constant(value: T) -> Self {
        Self::new(vec![], Box::new(ASTRepr::Constant(value)))
    }

    /// Get the arity (number of arguments) of this lambda
    #[must_use]
    pub fn arity(&self) -> usize {
        self.var_indices.len()
    }

    /// Check if this is an identity lambda pattern (λx.x)
    #[must_use]
    pub fn is_identity(&self) -> bool {
        self.var_indices.len() == 1
            && matches!(self.body.as_ref(), ASTRepr::Variable(var) if *var == self.var_indices[0])
    }

    /// Check if this is a constant lambda pattern (λ_.c)
    #[must_use]
    pub fn is_constant(&self) -> bool {
        self.var_indices.is_empty() || matches!(self.body.as_ref(), ASTRepr::Constant(_))
    }
}

/// Additional convenience methods for `ASTRepr<T>` with generic types
impl<T> ASTRepr<T>
where
    T: Scalar + ExpressionType,
{
    /// Power operation with natural syntax
    #[must_use]
    pub fn pow(self, exp: ASTRepr<T>) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Pow(Box::new(self), Box::new(exp))
    }

    /// Power operation with reference
    #[must_use]
    pub fn pow_ref(&self, exp: &ASTRepr<T>) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Pow(Box::new(self.clone()), Box::new(exp.clone()))
    }

    /// Natural logarithm
    #[must_use]
    pub fn ln(self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Ln(Box::new(self))
    }

    /// Natural logarithm with reference
    #[must_use]
    pub fn ln_ref(&self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Ln(Box::new(self.clone()))
    }

    /// Exponential function
    #[must_use]
    pub fn exp(self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Exp(Box::new(self))
    }

    /// Exponential function with reference
    #[must_use]
    pub fn exp_ref(&self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Exp(Box::new(self.clone()))
    }

    /// Square root (implemented as x^0.5 for unified power handling)
    #[must_use]
    pub fn sqrt(self) -> ASTRepr<T>
    where
        T: Float + FromPrimitive,
    {
        let half = T::from_f64(0.5).unwrap_or_else(|| {
            panic!("Type T must support conversion from f64 for sqrt operation")
        });
        ASTRepr::Pow(Box::new(self), Box::new(ASTRepr::Constant(half)))
    }

    /// Square root with reference (implemented as x^0.5 for unified power handling)
    #[must_use]
    pub fn sqrt_ref(&self) -> ASTRepr<T>
    where
        T: Float + FromPrimitive,
    {
        let half = T::from_f64(0.5).unwrap_or_else(|| {
            panic!("Type T must support conversion from f64 for sqrt operation")
        });
        ASTRepr::Pow(Box::new(self.clone()), Box::new(ASTRepr::Constant(half)))
    }

    /// Sine function
    #[must_use]
    pub fn sin(self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Sin(Box::new(self))
    }

    /// Sine function with reference
    #[must_use]
    pub fn sin_ref(&self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Sin(Box::new(self.clone()))
    }

    /// Cosine function
    #[must_use]
    pub fn cos(self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Cos(Box::new(self))
    }

    /// Cosine function with reference
    #[must_use]
    pub fn cos_ref(&self) -> ASTRepr<T>
    where
        T: Float,
    {
        ASTRepr::Cos(Box::new(self.clone()))
    }
}

// Custom PartialOrd implementation for ASTRepr that handles floating point numbers
impl<T: ExpressionType + PartialOrd> PartialOrd for ASTRepr<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use std::cmp::Ordering;

        // First compare by variant discriminant using a helper function
        let self_order = self.variant_order();
        let other_order = other.variant_order();

        match self_order.partial_cmp(&other_order) {
            Some(Ordering::Equal) => {
                // Same variant, compare contents
                match (self, other) {
                    (ASTRepr::Constant(a), ASTRepr::Constant(b)) => a.partial_cmp(b),
                    (ASTRepr::Variable(a), ASTRepr::Variable(b)) => a.partial_cmp(b),
                    (ASTRepr::BoundVar(a), ASTRepr::BoundVar(b)) => a.partial_cmp(b),
                    (ASTRepr::Let(a_id, a_expr, a_body), ASTRepr::Let(b_id, b_expr, b_body)) => {
                        a_id.partial_cmp(b_id).and_then(|ord| {
                            if ord == Ordering::Equal {
                                a_expr.partial_cmp(b_expr).and_then(|ord2| {
                                    if ord2 == Ordering::Equal {
                                        a_body.partial_cmp(b_body)
                                    } else {
                                        Some(ord2)
                                    }
                                })
                            } else {
                                Some(ord)
                            }
                        })
                    }
                    (ASTRepr::Add(a), ASTRepr::Add(b)) => a.partial_cmp(b),
                    (ASTRepr::Mul(a), ASTRepr::Mul(b)) => a.partial_cmp(b),
                    (ASTRepr::Sub(a1, a2), ASTRepr::Sub(b1, b2)) => {
                        a1.partial_cmp(b1).and_then(|ord| {
                            if ord == Ordering::Equal {
                                a2.partial_cmp(b2)
                            } else {
                                Some(ord)
                            }
                        })
                    }
                    (ASTRepr::Div(a1, a2), ASTRepr::Div(b1, b2)) => {
                        a1.partial_cmp(b1).and_then(|ord| {
                            if ord == Ordering::Equal {
                                a2.partial_cmp(b2)
                            } else {
                                Some(ord)
                            }
                        })
                    }
                    (ASTRepr::Pow(a1, a2), ASTRepr::Pow(b1, b2)) => {
                        a1.partial_cmp(b1).and_then(|ord| {
                            if ord == Ordering::Equal {
                                a2.partial_cmp(b2)
                            } else {
                                Some(ord)
                            }
                        })
                    }
                    (ASTRepr::Neg(a), ASTRepr::Neg(b))
                    | (ASTRepr::Ln(a), ASTRepr::Ln(b))
                    | (ASTRepr::Exp(a), ASTRepr::Exp(b))
                    | (ASTRepr::Sin(a), ASTRepr::Sin(b))
                    | (ASTRepr::Cos(a), ASTRepr::Cos(b))
                    | (ASTRepr::Sqrt(a), ASTRepr::Sqrt(b)) => a.partial_cmp(b),
                    (ASTRepr::Sum(a), ASTRepr::Sum(b)) => a.partial_cmp(b),
                    (ASTRepr::Lambda(a), ASTRepr::Lambda(b)) => a.partial_cmp(b),
                    _ => unreachable!("Same discriminant should mean same variant"),
                }
            }
            other_ord => other_ord,
        }
    }
}

impl<T: ExpressionType + PartialOrd> PartialOrd for Collection<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use std::cmp::Ordering;

        let self_order = self.variant_order();
        let other_order = other.variant_order();

        match self_order.partial_cmp(&other_order) {
            Some(Ordering::Equal) => match (self, other) {
                (Collection::Empty, Collection::Empty) => Some(Ordering::Equal),
                (Collection::Singleton(a), Collection::Singleton(b)) => a.partial_cmp(b),
                (
                    Collection::Range { start: s1, end: e1 },
                    Collection::Range { start: s2, end: e2 },
                ) => s1.partial_cmp(s2).and_then(|ord| {
                    if ord == Ordering::Equal {
                        e1.partial_cmp(e2)
                    } else {
                        Some(ord)
                    }
                }),
                (Collection::Variable(a), Collection::Variable(b)) => a.partial_cmp(b),
                (
                    Collection::Filter {
                        collection: c1,
                        predicate: p1,
                    },
                    Collection::Filter {
                        collection: c2,
                        predicate: p2,
                    },
                ) => c1.partial_cmp(c2).and_then(|ord| {
                    if ord == Ordering::Equal {
                        p1.partial_cmp(p2)
                    } else {
                        Some(ord)
                    }
                }),
                (
                    Collection::Map {
                        lambda: l1,
                        collection: c1,
                    },
                    Collection::Map {
                        lambda: l2,
                        collection: c2,
                    },
                ) => l1.partial_cmp(l2).and_then(|ord| {
                    if ord == Ordering::Equal {
                        c1.partial_cmp(c2)
                    } else {
                        Some(ord)
                    }
                }),
                (Collection::DataArray(a), Collection::DataArray(b)) => a.partial_cmp(b),
                _ => unreachable!("Same discriminant should mean same variant"),
            },
            other_ord => other_ord,
        }
    }
}

impl<T: ExpressionType + PartialOrd> PartialOrd for Lambda<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use std::cmp::Ordering;

        self.var_indices
            .partial_cmp(&other.var_indices)
            .and_then(|ord| {
                if ord == Ordering::Equal {
                    self.body.partial_cmp(&other.body)
                } else {
                    Some(ord)
                }
            })
    }
}

// Custom PartialOrd implementation for MultiSet
impl<T: PartialOrd + Clone> PartialOrd for MultiSet<T> {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        // Compare element by element in sorted order
        let self_elements: Vec<_> = self.iter().collect();
        let other_elements: Vec<_> = other.iter().collect();
        self_elements.partial_cmp(&other_elements)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ast_repr_basic_operations() {
        let x = ASTRepr::<f64>::Variable(0);
        let y = ASTRepr::<f64>::Variable(1);
        let const_2 = ASTRepr::<f64>::Constant(2.0);

        // Test addition
        let add_expr = ASTRepr::add_binary(x.clone(), y.clone());
        assert_eq!(add_expr.count_operations(), 1);

        // Test multiplication
        let mul_expr = ASTRepr::mul_binary(x.clone(), const_2.clone());
        assert_eq!(mul_expr.count_operations(), 1);

        // Test complex expression: (x + y) * 2
        let complex_expr = ASTRepr::mul_binary(add_expr, const_2);
        assert_eq!(complex_expr.count_operations(), 2); // one add, one mul
    }

    #[test]
    fn test_variable_index_access() {
        let expr: ASTRepr<f64> = ASTRepr::Variable(5);
        assert_eq!(expr.variable_index(), Some(5));

        let expr: ASTRepr<f64> = ASTRepr::Constant(42.0);
        assert_eq!(expr.variable_index(), None);
    }

    #[test]
    fn test_transcendental_functions() {
        let x = ASTRepr::<f64>::Variable(0);

        // Test sine
        let sin_expr = x.clone().sin();
        match sin_expr {
            ASTRepr::Sin(_) => {}
            _ => panic!("Expected sine expression"),
        }

        // Test exponential
        let exp_expr = x.clone().exp();
        match exp_expr {
            ASTRepr::Exp(_) => {}
            _ => panic!("Expected exponential expression"),
        }

        // Test natural logarithm
        let ln_expr = x.ln();
        match ln_expr {
            ASTRepr::Ln(_) => {}
            _ => panic!("Expected natural logarithm expression"),
        }
    }

    #[test]
    fn test_convenience_methods() {
        let x = ASTRepr::<f64>::Variable(0);
        let two = ASTRepr::<f64>::Constant(2.0);

        // Test power with reference
        let pow_expr = x.pow_ref(&two);
        match pow_expr {
            ASTRepr::Pow(_, _) => {}
            _ => panic!("Expected power expression"),
        }

        // Test sqrt with reference (now creates Pow(x, 0.5))
        let sqrt_expr = x.sqrt_ref();
        match sqrt_expr {
            ASTRepr::Pow(base, exp) => {
                // Verify it's x^0.5
                match (base.as_ref(), exp.as_ref()) {
                    (ASTRepr::Variable(0), ASTRepr::Constant(val))
                        if (*val - 0.5).abs() < 1e-15 => {}
                    _ => panic!("Expected Pow(x, 0.5) for sqrt"),
                }
            }
            _ => panic!("Expected power expression (x^0.5) for sqrt"),
        }
    }
}

// Additional methods requiring Scalar trait bounds
impl<T: Scalar + ExpressionType + PartialOrd> ASTRepr<T> {
    /// Count the total number of operations in the expression tree
    /// Uses stack-based visitor pattern to prevent stack overflow on deep expressions
    pub fn count_operations(&self) -> usize {
        use crate::ast::ast_utils::visitors::OperationCountVisitor;
        OperationCountVisitor::count_operations(self)
    }

    /// Count summation operations specifically
    /// Uses stack-based visitor pattern to prevent stack overflow on deep expressions
    pub fn count_summations(&self) -> usize {
        use crate::ast::ast_utils::visitors::SummationCountVisitor;
        match self {
            ASTRepr::Sum(_) => 1 + SummationCountVisitor::count_summations(self),
            _ => SummationCountVisitor::count_summations(self),
        }
    }
}

impl<T: Scalar + ExpressionType + PartialOrd> Collection<T> {
    /// Count operations in the collection
    #[must_use]
    pub fn count_operations(&self) -> usize {
        match self {
            Collection::Empty => 0,
            Collection::Singleton(expr) => expr.count_operations(),
            Collection::Range { start, end } => start.count_operations() + end.count_operations(),
            Collection::Variable(_) => 0, // Variable reference has no internal operations
            Collection::Filter {
                collection,
                predicate,
            } => 1 + collection.count_operations() + predicate.count_operations(),
            Collection::Map { lambda, collection } => {
                1 + lambda.count_operations() + collection.count_operations()
            }
            Collection::DataArray(_) => 0, // Embedded data has no operations
        }
    }

    /// Count summations in the collection
    #[must_use]
    pub fn count_summations(&self) -> usize {
        match self {
            Collection::Empty => 0,
            Collection::Variable(_) => 0, // Variable reference has no internal summations
            Collection::Singleton(expr) => expr.count_summations(),
            Collection::Range { start, end } => start.count_summations() + end.count_summations(),
            Collection::Filter {
                collection,
                predicate,
            } => collection.count_summations() + predicate.count_summations(),
            Collection::Map { lambda, collection } => {
                lambda.count_summations() + collection.count_summations()
            }
            Collection::DataArray(_) => 0, // Embedded data has no summations
        }
    }
}

impl<T: Scalar + ExpressionType + PartialOrd> Lambda<T> {
    /// Count operations in the lambda
    #[must_use]
    pub fn count_operations(&self) -> usize {
        self.body.count_operations()
    }

    /// Count summations in the lambda
    #[must_use]
    pub fn count_summations(&self) -> usize {
        self.body.count_summations()
    }
}
