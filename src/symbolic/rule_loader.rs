//! Rule Loader for Egglog Integration
//!
//! This module provides functionality to load, validate, and combine
//! egglog rule files for mathematical optimization.

use crate::error::{MathCompileError, Result};
use std::fs;
use std::path::PathBuf;

/// Categories of mathematical rules available
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RuleCategory {
    /// Core datatypes (always required)
    CoreDatatypes,
    /// Basic arithmetic operations
    BasicArithmetic,
    /// Transcendental functions (exp, ln, etc.)
    Transcendental,
    /// Trigonometric functions (sin, cos, etc.)
    Trigonometric,
    /// Summation rules
    Summation,
}

impl RuleCategory {
    /// Get the filename for this rule category
    #[must_use]
    pub fn filename(&self) -> &'static str {
        match self {
            RuleCategory::CoreDatatypes => "core_datatypes.egg",
            RuleCategory::BasicArithmetic => "basic_arithmetic.egg",
            RuleCategory::Transcendental => "transcendental.egg",
            RuleCategory::Trigonometric => "trigonometric.egg",
            RuleCategory::Summation => "summation.egg",
        }
    }

    /// Get a description of this rule category
    #[must_use]
    pub fn description(&self) -> &'static str {
        match self {
            RuleCategory::CoreDatatypes => "Core mathematical expression datatypes",
            RuleCategory::BasicArithmetic => "Basic arithmetic operations and identities",
            RuleCategory::Transcendental => "Exponential and logarithmic functions",
            RuleCategory::Trigonometric => "Trigonometric functions and identities",
            RuleCategory::Summation => "Summation linearity and algebraic rules",
        }
    }

    /// Get all available rule categories
    #[must_use]
    pub fn all() -> Vec<RuleCategory> {
        vec![
            RuleCategory::CoreDatatypes,
            RuleCategory::BasicArithmetic,
            RuleCategory::Transcendental,
            RuleCategory::Trigonometric,
            RuleCategory::Summation,
        ]
    }

    /// Get the default set of rule categories for basic optimization
    #[must_use]
    pub fn default_set() -> Vec<RuleCategory> {
        vec![
            RuleCategory::CoreDatatypes,
            RuleCategory::BasicArithmetic,
            RuleCategory::Transcendental,
        ]
    }
}

/// Configuration for rule loading
#[derive(Debug, Clone)]
pub struct RuleConfig {
    /// Categories of rules to load
    pub categories: Vec<RuleCategory>,
    /// Custom rules directory (defaults to "rules/")
    pub rules_directory: Option<PathBuf>,
    /// Whether to validate rule syntax
    pub validate_syntax: bool,
    /// Whether to include debug comments in the combined program
    pub include_comments: bool,
}

impl Default for RuleConfig {
    fn default() -> Self {
        Self {
            categories: RuleCategory::default_set(),
            rules_directory: None,
            validate_syntax: true,
            include_comments: false,
        }
    }
}

/// Rule loader for egglog programs
pub struct RuleLoader {
    config: RuleConfig,
    rules_dir: PathBuf,
}

impl RuleLoader {
    /// Create a new rule loader with the given configuration
    #[must_use]
    pub fn new(config: RuleConfig) -> Self {
        let rules_dir = config
            .rules_directory
            .clone()
            .unwrap_or_else(|| PathBuf::from("rules"));

        Self { config, rules_dir }
    }

    /// Create a rule loader with default configuration
    #[must_use]
    pub fn default() -> Self {
        Self::new(RuleConfig::default())
    }

    /// Load and combine all configured rule files into a single egglog program
    pub fn load_rules(&self) -> Result<String> {
        let mut program = String::new();

        if self.config.include_comments {
            program.push_str("; Combined Egglog Program for MathCompile\n");
            program.push_str("; Generated by RuleLoader\n\n");
        }

        // Always load core datatypes first
        if !self
            .config
            .categories
            .contains(&RuleCategory::CoreDatatypes)
        {
            let core_content = self.load_rule_file(&RuleCategory::CoreDatatypes)?;
            program.push_str(&core_content);
            program.push('\n');
        }

        // Load all configured rule categories
        for category in &self.config.categories {
            if self.config.include_comments {
                program.push_str("; ========================================\n");
                program.push_str(&format!("; {}\n", category.description()));
                program.push_str("; ========================================\n\n");
            }

            let content = self.load_rule_file(category)?;
            program.push_str(&content);
            program.push('\n');
        }

        if self.config.validate_syntax {
            self.validate_program_syntax(&program)?;
        }

        Ok(program)
    }

    /// Load a specific rule file
    fn load_rule_file(&self, category: &RuleCategory) -> Result<String> {
        let file_path = self.rules_dir.join(category.filename());

        fs::read_to_string(&file_path).map_err(|e| {
            MathCompileError::Optimization(format!(
                "Failed to load rule file {}: {}",
                file_path.display(),
                e
            ))
        })
    }

    /// Validate the syntax of the combined program
    fn validate_program_syntax(&self, program: &str) -> Result<()> {
        // Basic syntax validation
        let mut paren_count = 0;
        let mut in_comment = false;

        for line in program.lines() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with(';') {
                continue;
            }

            for ch in line.chars() {
                match ch {
                    ';' => in_comment = true,
                    '\n' => in_comment = false,
                    '(' if !in_comment => paren_count += 1,
                    ')' if !in_comment => paren_count -= 1,
                    _ => {}
                }
            }
            in_comment = false; // Reset at end of line
        }

        if paren_count != 0 {
            return Err(MathCompileError::Optimization(format!(
                "Unbalanced parentheses in egglog program: {paren_count} unclosed"
            )));
        }

        // Check for required elements
        if !program.contains("datatype Math") {
            return Err(MathCompileError::Optimization(
                "Missing required 'datatype Math' definition".to_string(),
            ));
        }

        Ok(())
    }

    /// Get information about available rule files
    pub fn list_available_rules(&self) -> Result<Vec<(RuleCategory, bool, String)>> {
        let mut rules_info = Vec::new();

        for category in RuleCategory::all() {
            let file_path = self.rules_dir.join(category.filename());
            let exists = file_path.exists();
            let description = category.description().to_string();
            rules_info.push((category, exists, description));
        }

        Ok(rules_info)
    }

    /// Check if all required rule files exist
    pub fn validate_rule_files(&self) -> Result<()> {
        for category in &self.config.categories {
            let file_path = self.rules_dir.join(category.filename());
            if !file_path.exists() {
                return Err(MathCompileError::Optimization(format!(
                    "Required rule file not found: {}",
                    file_path.display()
                )));
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rule_category_filename() {
        assert_eq!(RuleCategory::CoreDatatypes.filename(), "core_datatypes.egg");
        assert_eq!(
            RuleCategory::BasicArithmetic.filename(),
            "basic_arithmetic.egg"
        );
        assert_eq!(
            RuleCategory::Transcendental.filename(),
            "transcendental.egg"
        );
    }

    #[test]
    fn test_default_rule_config() {
        let config = RuleConfig::default();
        assert!(config.categories.contains(&RuleCategory::CoreDatatypes));
        assert!(config.categories.contains(&RuleCategory::BasicArithmetic));
        assert!(config.validate_syntax);
    }

    #[test]
    fn test_rule_loader_creation() {
        let loader = RuleLoader::default();
        assert_eq!(loader.rules_dir, PathBuf::from("rules"));
    }

    #[test]
    fn test_syntax_validation() {
        let loader = RuleLoader::default();

        // Valid program
        let valid_program = "(datatype Math (Num f64))";
        assert!(loader.validate_program_syntax(valid_program).is_ok());

        // Invalid program - unbalanced parentheses
        let invalid_program = "(datatype Math (Num f64)";
        assert!(loader.validate_program_syntax(invalid_program).is_err());

        // Invalid program - missing datatype
        let missing_datatype = "(rewrite (Add ?x ?y) (Add ?y ?x))";
        assert!(loader.validate_program_syntax(missing_datatype).is_err());
    }
}
