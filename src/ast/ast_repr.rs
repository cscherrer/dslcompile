/// Core AST representation for mathematical expressions
///
/// This enum represents all possible mathematical operations and values in the DSL.
/// It uses generic type T to support different numeric types (f64, f32, etc.).
/// Variables are referenced by index for performance and to enable efficient
/// egglog integration.
#[derive(Debug, Clone, PartialEq)]
pub enum ASTRepr<T> {
    /// Constants: 42.0, π, etc.
    Constant(T),
    /// Variables: x, y, z (referenced by index for performance)
    /// Maps to (UserVar i64) in egglog
    Variable(usize),
    /// CSE-bound variables (generated by Common Subexpression Elimination)
    /// Maps to (BoundVar i64) in egglog
    BoundVar(usize),
    /// Let bindings for Common Subexpression Elimination
    /// Let(binding_id, expression, body) maps to (Let i64 Math Math) in egglog
    Let(usize, Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    /// Binary operations
    Add(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Sub(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Mul(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Div(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    Pow(Box<ASTRepr<T>>, Box<ASTRepr<T>>),
    /// Unary operations
    Neg(Box<ASTRepr<T>>),
    Ln(Box<ASTRepr<T>>),
    Exp(Box<ASTRepr<T>>),
    Sin(Box<ASTRepr<T>>),
    Cos(Box<ASTRepr<T>>),
    Sqrt(Box<ASTRepr<T>>),
    /// Compositional summation using iterator abstraction
    ///
    /// Creates expressions like:
    /// - Simple: `Sum(Range(1, n))` → sum over range with identity
    /// - Mapped: `Sum(Map(f, Range(1, n)))` → sum f(i) for i in 1..n
    /// - Data: `Sum(Variable(0))` → sum over data array
    /// - Complex: `Sum(Map(f, Union(A, B)))` → sum f(x) for x in A∪B
    Sum(Box<Collection<T>>),
}

impl<T> ASTRepr<T> {
    /// Count the total number of operations in the expression tree
    pub fn count_operations(&self) -> usize {
        match self {
            ASTRepr::Constant(_) | ASTRepr::Variable(_) | ASTRepr::BoundVar(_) => 0,
            ASTRepr::Add(left, right)
            | ASTRepr::Sub(left, right)
            | ASTRepr::Mul(left, right)
            | ASTRepr::Div(left, right)
            | ASTRepr::Pow(left, right) => 1 + left.count_operations() + right.count_operations(),
            ASTRepr::Let(_, expr, body) => 1 + expr.count_operations() + body.count_operations(),
            ASTRepr::Neg(inner)
            | ASTRepr::Ln(inner)
            | ASTRepr::Exp(inner)
            | ASTRepr::Sin(inner)
            | ASTRepr::Cos(inner)
            | ASTRepr::Sqrt(inner) => 1 + inner.count_operations(),
            ASTRepr::Sum(collection) => 1 + collection.count_operations(),
        }
    }

    /// Get the variable index if this is a variable, otherwise None
    pub fn variable_index(&self) -> Option<usize> {
        match self {
            ASTRepr::Variable(index) | ASTRepr::BoundVar(index) => Some(*index),
            _ => None,
        }
    }

    /// Count summation operations specifically
    pub fn count_summations(&self) -> usize {
        match self {
            ASTRepr::Sum(_) => 1 + self.count_summations_recursive(),
            _ => self.count_summations_recursive(),
        }
    }

    /// Recursively count summations in subexpressions
    fn count_summations_recursive(&self) -> usize {
        match self {
            ASTRepr::Constant(_) | ASTRepr::Variable(_) | ASTRepr::BoundVar(_) => 0,
            ASTRepr::Add(left, right)
            | ASTRepr::Sub(left, right)
            | ASTRepr::Mul(left, right)
            | ASTRepr::Div(left, right)
            | ASTRepr::Pow(left, right) => left.count_summations() + right.count_summations(),
            ASTRepr::Let(_, expr, body) => expr.count_summations() + body.count_summations(),
            ASTRepr::Neg(inner)
            | ASTRepr::Ln(inner)
            | ASTRepr::Exp(inner)
            | ASTRepr::Sin(inner)
            | ASTRepr::Cos(inner)
            | ASTRepr::Sqrt(inner) => inner.count_summations(),
            ASTRepr::Sum(collection) => collection.count_summations(),
        }
    }
} 